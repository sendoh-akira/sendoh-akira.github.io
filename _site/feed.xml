<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>Sendoh Akira</title>
    <link>https://sendoh-akira.github.io</link>
    <description>good luck</description>
    
      <item>
        <title>jni使用详解</title>
        <link>https://sendoh-akira.github.io/2016/04/05/jni.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/04/05/jni.html</guid>
        <pubDate>Tue, 05 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;开发中难免要使用jni，现在系统的学习总结一下使用的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;jni&quot;&gt;1 jni概述&lt;/h5&gt;

&lt;p&gt;jni是Java Native Interface的缩写，中文译为“java本地方法接口”。通俗的说，jni是一种技术，通过jni你可以：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java程序中的函数可以调用Native语言写的函数，Native一般是指C/C++编写的代码。&lt;/li&gt;
  &lt;li&gt;Native程序中的函数可以调用Java层的函数，也就是说在C/C++程序中可以调用java的函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jnijni&quot;&gt;2 加载jni库以及注册jni函数&lt;/h5&gt;

&lt;p&gt;加载jni库非常简单，只需要在调用Native函数之前使用&lt;code&gt;System.loadLibrary(&quot;your_libray_name&quot;)&lt;/code&gt;即可。我们的通常做法是在class中的静态块中加载，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.jimbo.jni;

public class JNIInterface {

  static {
    System.loadLibrary(&quot;your_libray_name&quot;);
  }

  //这里可以定义你的Native函数
  public static native final void native_say_hello();

  int a;
  int b;
  public int calc() {
    return a+b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了&lt;code&gt;java&lt;/code&gt;代码编写的方法，那么问题来了，Native代码怎么编写呢？java函数怎么找到对应的Native函数呢？all right,让我们来看一下注册jni的两种方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;借助java的工具程序&lt;code&gt;javah&lt;/code&gt;来实现这一过程。答题流程是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编写java代码，然后编译生成&lt;code&gt;.class&lt;/code&gt;文件。&lt;/li&gt;
  &lt;li&gt;使用javah，例如&lt;code&gt;javah -o output packname.classname&lt;/code&gt;来生成一个叫做&lt;code&gt;output.h&lt;/code&gt;的头文件。&lt;/li&gt;
  &lt;li&gt;在jni层实现这些函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的&lt;code&gt;JNIInterface&lt;/code&gt;类经过上述操作后会得到这样的头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
//...省略
//注：如果java的函数中已经有了“_”，则&quot;_&quot;将会被替换成&quot;_l&quot;
JNIEXPORT void JNICALL Java_com_jimbo_jni_JNIInterface_native_lsay_lhello(JNIEnv *, jclass);

//...省略
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，这个Native函数的名字就是包名+函数名，只是因为“.”在c中有特殊的含义，所以被替换成了”_“。这个过程是这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当java层调用native_say_hello()函数时，他会从对应的JNI库中寻找Java_com_jimbo_jni_JNIInterface_native_lsay_lhello()函数，如果没有就会报错。如果找的到，则会为这个native_say_hello()和Java_com_jimbo_jni_JNIInterface_native_lsay_lhello()建立一个关联关系，其实就是保存jni层函数的函数指针。以后再调用native_say_hello()函数时，直接使用这个函数指针就可以了。当然这个过程是虚拟机来完成的，不需要我们操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;动态注册&lt;/p&gt;

    &lt;p&gt;既然java函数和native函数时一一对应的，那么是不是有一种结构来保存这些数据信息呢？答案是肯定的。在jni技术中，用一个&lt;code&gt;JNINativeMethod&lt;/code&gt;来保存，结构定义如下：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct {
  //java函数名 不用携带包名，待会会有其他方式提供包名，
  //这样查找起来效率就会更高
  const char *name;
  //函数签名信息，包括函数的参数以及函数的返回值等信息
  const char *signature;
  //函数指针，类型为void*
  void* fnptr;
} JNINativeMethod;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，这些对应数据什么时候会被加载出来了呢？其实在调用&lt;code&gt;System.loadLibrary(&quot;your_libray_name&quot;);&lt;/code&gt;之后，紧接着会查看该库中一个叫做&lt;code&gt;JNI_OnLoad()&lt;/code&gt;的函数，如果有就会调用它，动态注册就需要在这里完成。那么究竟如何实现这一个过程呢？需要调用两个函数就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jclass clazz = (*env) -&amp;gt; FindClass(env, className);

(*env) -&amp;gt; RegisterNatives(env, clazz, gMethods, numMethods);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体注册过程可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;string.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;assert.h&amp;gt;

//这个函数是对应java函数的
jstring native_say_hello(JNIEnv *env, jobject thiz) {
  return (*env) -&amp;gt; NewStringUTF(env, &quot;hello, i am from jni~&quot;);
}

//这个函数提供方法的对应信息，通过创建JNINativeMethod结构体来实现
//至于那么参数什么意思 待会具体说
static JNINativeMethod gMethods[] = {
  {&quot;native_say_hello&quot;, &quot;()Ljava/lang/String&quot;, (void)*native_say_hello},
}

//为类的某一个方法注册
static int registerNativeMethod(JNIEnv *env, const char* className, JNINativeMethod *gMethods, int numbers) {
  jclass  clazz = (*env) -&amp;gt; FindClass(env, className);
  if (null == clazz) {
    return JNI_FALSE;
  }
  if ((*env)-&amp;gt;RegisterNatives(env, clazz, gMethods, numMethods) &amp;lt; 0) {  
        return JNI_FALSE;  
  }
  return JNI_TURE;
}

//为所有类的方法注册
static int registerNatives(JNIEnv* env) {  
    const char* kClassName = &quot;com/jimbo/jni/JNIInterface&quot;;//指定要注册的类  
    return registerNativeMethods(env, kClassName, gMethods,  
            sizeof(gMethods) / sizeof(gMethods[0]));
}

//如果成功返回JNI版本, 失败返回-1
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {  
    JNIEnv* env = NULL;  

    if ((*vm)-&amp;gt;GetEnv(vm, (void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {  
        return -1;  
    }  
    assert(env != NULL);  

    if (!registerNatives(env)) {//注册  
        return -1;  
    }  
    //成功  
    return JNI_VERSION_1_4;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的方法我们就可以将jni函数和java的函数注册在一起了。但是上面代码似乎还是有点麻烦的，
其实jni的AndroidRunTime类提供了一个&lt;code&gt;registerNativeMethods()&lt;/code&gt;方法，可以更加简单的实现这
一过程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;string.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;assert.h&amp;gt;

jstring native_say_hello(JNIEnv *env, jobject thiz) {
  return (*env) -&amp;gt; NewStringUTF(env, &quot;hello, i am from jni~&quot;);
}

static JNINativeMethod gMethods[] = {
  {&quot;native_say_hello&quot;, &quot;()Ljava/lang/String;&quot;, (void)*native_say_hello},
}
//以上代码和前面是一样的

//如果成功返回JNI版本, 失败返回-1
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {  
    JNIEnv* env = NULL;   

    if ((*vm)-&amp;gt;GetEnv(vm, (void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {  
        return -1;  
    }  
    assert(env != NULL);  

    if (AndroidRunTime::registerNativeMethods(env, &quot;com/jimbo/jni/JNIInterface&quot;, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) &amp;lt; 0) {//注册  
        return -1;  
    }  
    //成功  
    return JNI_VERSION_1_4;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码比较好理解，但是JNINativeMethod中的signature可能会存在疑问。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&quot;()V&quot;
&quot;()I&quot;
&quot;(II)Ljava/lang/String&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上这些是与函数参数以及返回值一一对对应的。&lt;code&gt;()&lt;/code&gt;里面表示参数，&lt;code&gt;()&lt;/code&gt;外表示的函数的返回值。
比如&lt;code&gt;(II)Ljava/lang/String&lt;/code&gt;就对应这个函数&lt;code&gt;jstring functionName(int ,int)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;具体的对应关系如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;java类型&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;c类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;void&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;void&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jboolean&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;I&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jint&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jlong&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jdouble&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jfloat&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbyte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshort&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[I&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jintarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshortarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbytearray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jchararray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[S&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshortarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jdoublearray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[j&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jlongarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[z&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbooleanarray&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上是关于基本类型和基本类型的数组，那么类是如何表示的呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果Java函数的参数是class，则以”L”开头，以”;”结尾中间是用”/” 隔开的包及类名。而其对应的C函数名的参数则为jobject. 一个例外是String类，其对应的类为jstring
Ljava/lang/String; String jstring
Ljava/net/Socket; Socket jobject&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;jnienv&quot;&gt;3 JNIEnv介绍&lt;/h5&gt;

&lt;p&gt;JNIEnv，即JNIEnvironment，字面意思就是jni环境。其实他就是一个与线程相关的jni环境结构体。
JNIEnv提供了一些jni系统函数，通过这些函数我们可以做：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用java函数&lt;/li&gt;
  &lt;li&gt;操作jobject对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jnienvjobject&quot;&gt;4 通过JNIEnv操作jobject&lt;/h5&gt;

&lt;p&gt;我们都知道，类都是由方法和成员变量组成的，在jni的规则中，使用jfirldID和jMethod来表示java的
成员变量和方法，可通过jni下面的两个函数得到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jfieldId GetFieldID(jclass clazz, const char *name, const char *sig);
jMethod GetMethodID(jclass clazz, const char *name, const char *sig);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;jclass代表的java中的类，对应&lt;code&gt;java.lang.Class&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;第二个参数就是类的名称&lt;/li&gt;
  &lt;li&gt;第三个参数是函数签名，和前面介绍的一样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;得到jfieldId和jMethod后依然无法调用java函数。那到底该怎么做呢？
不着急，我们看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jint native_calc(JNIEnv *env, jobject thiz) {

  jclass clazz = env -&amp;gt; FindClass(&quot;com/jimbo/jni/JNIInterface&quot;);
  jmethodID java_calc_id = env -&amp;gt; GetMethodID(clazz, &quot;native_calc&quot;, &quot;()I&quot;);
  jfieldId a_id = env -&amp;gt; GetFieldID(clazz, &quot;a&quot;, &quot;I&quot;);
  jfieldId b_id = env -&amp;gt; GetFieldID(clazz, &quot;b&quot;, &quot;I&quot;);
  jint a = env -&amp;gt; GetIntField(clazz, thiz, a_id);
  jint b = env -&amp;gt; GetIntField(clazz, thiz, b_id);
  return env -&amp;gt; CallIntMethod(env, thiz, java_calc_id, a, b);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这段代码我们知道jni是通过&lt;code&gt;CallIntMethod()&lt;/code&gt;函数来调用了java的函数。&lt;/p&gt;

&lt;p&gt;实际上，jni有一系列类似的函数，形式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;//调用函数
//最后参数是调用函数的参数
NativeType Call&amp;lt;Type&amp;gt;Method(JNIEnv *env, jobject thiz, jmethodID methodID, ...);

//获取成员变量的值
NativeType Get&amp;lt;Type&amp;gt;Field(JNIEnv *env, jobject thiz, jfieldId fieldID);
//或者是
void Set&amp;lt;Typr&amp;gt;FieldID(JNIEnv *env, jobject thiz, jfieldId fieldID, NativeType value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用的还用如下函数:&lt;/p&gt;

&lt;p&gt;GetObjectField(),GetIntField(),GetShortField(),GetCharField()等等。&lt;/p&gt;

&lt;h5 id=&quot;jni-1&quot;&gt;5 jni的垃圾回收以及异常处理&lt;/h5&gt;

&lt;p&gt;在jni中，有三种类型的引用，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Local Reference：包括函数调用是传入的参数，在函数内创建的jobject。Local Reference
最大的特点就是，一旦jni函数结束，就会被回收。&lt;/li&gt;
  &lt;li&gt;Global Reference：全局引用，这种对象不主动释放永远都不会被回收。&lt;/li&gt;
  &lt;li&gt;Weak Reference：弱全局引用，在运行过程中可能被回收。所以在使用前要调用IsSameObject()
来判断他是否已经被回收了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在使用完变量后也可以通过&lt;code&gt;env -&amp;gt; Delete&amp;lt;ReferenceType&amp;gt;Ref&lt;/code&gt;来主动释放内存。例如DeleteLocalRef();&lt;/p&gt;

&lt;p&gt;在jni中，提供了三个函数来截获和处理异常：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ExceptionOccured(),用来判断时候发生了异常。&lt;/li&gt;
  &lt;li&gt;ExceptionClear(),用来清理jni层发生的异常。&lt;/li&gt;
  &lt;li&gt;ThrowNew(),用来向java层抛出异常。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文参考了&lt;a href=&quot;https://book.douban.com/subject/6802440/&quot;&gt;邓凡平的深入理解Android 卷1&lt;/a&gt;以及&lt;a href=&quot;http://blog.csdn.net/chenfeng0104/article/details/7088600&quot;&gt;chenfeng0104的专栏-动态注册JNI&lt;/a&gt;。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>二叉树的分层遍历</title>
        <link>https://sendoh-akira.github.io/2016/03/14/suanfa-erchashufencengbianli.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/03/14/suanfa-erchashufencengbianli.html</guid>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;二叉树的分层遍历&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;题目要求：给定一个二叉树的root结点，然后按照每层从左到右的顺序将二叉树结点的值储存在一个二维数组中，每一层一个数组，每一个数组的元素是按照从左到右的顺序进行存储的。&lt;/p&gt;

&lt;p&gt;思路：二叉树的分层打印类似于图的广度优先遍历算法，我们可以借助一个队列实现这个过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化队列 将root结点加入到队列之中&lt;/li&gt;
  &lt;li&gt;判断当前队列是否为空
    &lt;ul&gt;
      &lt;li&gt;不为空，则出队队列的首元素 并且将不为空的结点入队列&lt;/li&gt;
      &lt;li&gt;为空则表示遍历完成&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过上述操作之后就可以得到二叉树分层遍历的顺序了。但是我们并不能得到每一个层都有什么元素这样的信息，我们还需要在遍历的过程中使用变量记录这一个过程。&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;last&lt;/code&gt;变量记录当前打印行的最右结点&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;nLast&lt;/code&gt;变量记录加入队列的最近一个元素&lt;/p&gt;

&lt;p&gt;在元素弹出的时候判断一下是否和&lt;code&gt;last&lt;/code&gt;元素相等，相等则表示要换行了，这时候要更新&lt;code&gt;last&lt;/code&gt;的值，就是将&lt;code&gt;nLast&lt;/code&gt;赋值给&lt;code&gt;last&lt;/code&gt;即可，这样就实现了这个功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
import java.util.*;

public class Java {

	public static void main(String[] args) {
		TreeNode one = new TreeNode(1);
		TreeNode two = new TreeNode(2);
		TreeNode three =new TreeNode(3);
		TreeNode four = new TreeNode(4);
		TreeNode five = new TreeNode(5);
		TreeNode six = new TreeNode(6);
		TreeNode seven = new TreeNode(7);
		TreeNode eight = new TreeNode(8);
		TreeNode nine = new TreeNode(9);
		TreeNode ten = new TreeNode(10);
		TreeNode n11 = new TreeNode(11);
		TreeNode n12 = new TreeNode(12);
		TreeNode n13 = new TreeNode(13);
		TreeNode n14 = new TreeNode(14);

		one.left = two;
		one.right = three;
		//two.left = four;
		two.right = five;
		three.left = six;
		three.right = seven;
		four.left = eight;
		//four.right = nine;
		//five.left = ten;
		five.right = n11;
		six.left = n12;
		six.right = n13;

		n13.right = n14;

		TreePrinter p = new TreePrinter();
		int[][] result = p.printTree(one);
		for (int i = 0; i &amp;lt; result.length; i++) {
			for (int j = 0; j &amp;lt; result[i].length; j++) {
				System.out.print(result[i][j]);
			}
			System.out.println(&quot;&quot;);
		}
	}

}

class TreePrinter {
    public int[][] printTree(TreeNode root) {
        // write code here
    	if (null == root) {
    		return null;
    	}

    	if (null == root.left &amp;amp;&amp;amp; null == root.right) {
    		int[][] result = ;
    		return result;
    	}

    	int[][] result = new int[10][];

    	Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;();	
    	TreeNode last = root;
    	TreeNode nLast = root.right == null ? root.left : root.right;

    	int i = 0;
    	int j = 0;

    	int numOfLine[] = new int[10];

    	result[i] = new int[1];

    	queue.add(root);

    	while(!queue.isEmpty()) {

    		TreeNode tree = queue.poll();
    		result[i][j++] = tree.val;
    		numOfLine[i]++;

    		if (tree.left != null) {
    			queue.add(tree.left);
    			nLast = tree.left;
    		}
    		if (tree.right != null) {
    			queue.add(tree.right);
    			nLast = tree.right;
    		}

    		if (last == tree) {
    			j = 0;
    			i++;
    			result[i] = new int[(int)(Math.pow((double)2, (double)i))];
    			last = nLast;
    		}

    		
    	}

    	int[][] r = new int[i][];
    	//System.out.println(i+&quot;&quot;);
    	for (int g = 0; g &amp;lt; i; g++) {
    		r[g] = new int[numOfLine[g]];
    		for (int h = 0; h &amp;lt; numOfLine[g]; h++) {
    			r[g][h] = result[g][h];
    		}
    	}
    	result = null;
    	return r;
    }
}

class TreeNode {
    public int val = 0;
    public TreeNode left = null;
    public TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}


&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>upsdnu使用说明</title>
        <link>https://sendoh-akira.github.io/2015/12/02/life-upsdnudescription.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/12/02/life-upsdnudescription.html</guid>
        <pubDate>Wed, 02 Dec 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;upsdnu使用说明
任何意见以及建议都可以反馈 在博客下面留言即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;BUG集合：
2016年3月15日20:58:09&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;由于采用thread去请求认证 可能会导致内存泄露问题&lt;/li&gt;
    &lt;li&gt;
      &lt;h2 id=&quot;section&quot;&gt;计算绩点操作数据的时候可能导致了精度丢失&lt;/h2&gt;
      &lt;p&gt;1.alpha_2.1 2016年1月6日16:46:29：(尚未处理)
java.lang.StringIndexOutOfBoundsException: length=0; regionStart=1; regionLength=-2
at java.lang.String.startEndAndLength(String.java:504)
at java.lang.String.substring(String.java:1333)
at com.jimbo.myapplication.MainActivity.getWifiName(MainActivity.java:315)
可能是WIFI的名字过长溢出了
2.alpha_2.0 2016年1月6日16:56:12: (已经处理)
at android.view.ViewRootImpl.setView(ViewRootImpl.java:677)
at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:248)
at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)
at android.app.Dialog.show(Dialog.java:281)
at com.gc.materialdesign.widgets.SnackBar.show(SnackBar.java:93)
可能是因为activity被切换到后台导致的问题&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-1&quot;&gt;1. 使用说明&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;SDNU WIFI连接模块
1.首先在菜单选项里面找到&lt;code&gt;设置sdnu账号&lt;/code&gt;
2.进入设置账号
3.在首页即可使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：软件没有任务后台服务，只会在网络状态改变的时候被激活(重启手机后没有打开过或者被强制关闭过软件不会被激活)，并且连接后完全释放资源。由于sdnu网络环境比较复杂，并不能保证每一次都能自动连接到网络，没有接收到通知的时候可以手动启动软件连接。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;成绩查询模块
1.在菜单选项里面找到&lt;code&gt;本学期成绩&lt;/code&gt;和&lt;code&gt;计算绩点&lt;/code&gt;
2.进入输入教务处&lt;code&gt;学号&lt;/code&gt;和&lt;code&gt;密码&lt;/code&gt;即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：这是我见过最丑的界面= =&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;2. 关于&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.如果有意见请在下面留言或者发送邮件到 zhongjinbao1994@gmail.com，欢迎大家反馈
2.代码开源 不会窃取用户信息
3.唯一指定软件下载地址 &lt;a href=&quot;http://www.pgyer.com/upsdun&quot;&gt;upsdnu-蒲公英&lt;/a&gt;，不要相信其他途径，防止被钓鱼。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-3&quot;&gt;3. 软件部分截图&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot.jpg&quot; alt=&quot;截图2&quot; /&gt;
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot1_meitu_2.jpg&quot; alt=&quot;截图3&quot; /&gt;
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot2_meitu_3.jpg&quot; alt=&quot;截图1&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>为什么使用sudo命令执行sh会报command not found错误</title>
        <link>https://sendoh-akira.github.io/2015/11/22/linux-sduoshcommandnotfound.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/22/linux-sduoshcommandnotfound.html</guid>
        <pubDate>Sun, 22 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;明明sh文件存在,为什么还会说命令找不到呢?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/poechant/article/details/7216892&quot;&gt;参考博客-Linux下执行一些命令前加sudo时出现command not found的原因&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了科(翻)学(墙)上网,一直在用&lt;a href=&quot;www.laod.cn&quot;&gt;laod&lt;/a&gt;给的hosts,非常感谢!为了能高效的更换hosts,想用sh来完成.由于涉及了系统文件的操作,所以需要使用sudo来用root权限执行.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo changehosts.sh
sudo:changehosts.sh 找不到命令
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是输出PATH看了一下,路径设置是没问题的.只好请教万能的&lt;a href=&quot;www.google.com&quot;&gt;google&lt;/a&gt;,终于找到了答案.&lt;/p&gt;

&lt;p&gt;原来,在Linux下用sudo执行某一命令时,是在原进程(parent process)的基础上fork出来一个子进程(child process),这个子进程是以root权限执行的.然后在子进程中,执行你在sudo后面跟的命令.在子进程中是无法调用涉及到父进程的状态的一些命令的,所以非系统内置命令会被拒绝.这就是为什么会出现command not found的提示.
原因找到了,但是文中没有给解决办法.
那我们该怎么办呢?
我们可以用&lt;code&gt;su - root&lt;/code&gt;开启root账号,然后执行完在退出.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su - root
密码:
root@username:#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行完我们发现我们已经取得了root权限,这时候执行准没错了.
但是令人失望的是还是找不到命令,这又是怎么了?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $PTAH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出发现没有我们设置的shell路径了,恍然大悟,我们已经切换到了root账号下面,设置也已经变了.这样的话我们只要先进入预先的目录然后在执行,ok,成功.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>计算nextDay的实现</title>
        <link>https://sendoh-akira.github.io/2015/11/22/java-nextday.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/22/java-nextday.html</guid>
        <pubDate>Sun, 22 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;实现nextDay算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;1.题目要求&lt;/h2&gt;

&lt;p&gt;用户从键盘输入”2014/11/11”,然后输出该输入的下一天日期是多少.
要求很简单,看上去也不是很复杂,但是要考虑到闰年,月份进位等等问题.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.思路分析&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;用户输入合法性问题&lt;/li&gt;
  &lt;li&gt;nextDay的推算算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们先看第一个问题:
这个比较简单,我们可以使用正则表达式来匹配用户的输入,当然了,只是正则表达式可能还无法完全约束合法,我们可以继续针对个别的在正确的校验.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//使用分隔符'/'分割年月日
//年份可以使用09或者2009这样的形式 月份使用1或者01 日使用01或者1
//至少有一位 至多有两位
//则可以得到下面的匹配规则
String pattern = &quot;^(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\\/(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))$&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样,就可以得到一个合法的类似于”2013/14/22”这样的字符串,但是我们发现,14月仍然是不合法的,仍需我们再次校验合法性.于是,可以封装三个函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isLegalYear(int year) {
	return year &amp;gt;= 1900 &amp;amp;&amp;amp; year &amp;lt; 3000;
}

public static boolean isLegalMonth(int month) {
	return month &amp;lt;= 12 &amp;amp;&amp;amp; month &amp;gt; 0;
}

public static boolean isLegalDay(int month, int day) {
	return mapDay.get(month).intValue() &amp;gt;= day;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样,我们就可以得到一个正确合法的输入日期,然后就可以依照算法,计算下一天.&lt;/p&gt;

&lt;p&gt;再看第二个问题:
算法说起来也比较简单,类似于一个加法器,只是各个位置上的进位法则不一样而已.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将day自加1
    &lt;ul&gt;
      &lt;li&gt;若day合法,返回该data&lt;/li&gt;
      &lt;li&gt;若day不合法,day赋值为1,month自加1
        &lt;ul&gt;
          &lt;li&gt;若month合法,返回该data&lt;/li&gt;
          &lt;li&gt;若month不合法,month赋值为1,year自加,返回data&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过上述算法计算,即可得到正确的日期了.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.具体实现&lt;/h2&gt;

&lt;p&gt;首先封装一个data数据类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyData {
	public MyData(int year, int month, int day) {
		this.day = day;
		this.month = month;
		this.year = year;
	}
	public int year;
	public int month;
	public int day;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import java.util.*;
import java.util.regex.*;

public class NextDay{

	public static Map&amp;lt;Integer, Integer&amp;gt; mapDay = new HashMap&amp;lt;Integer, Integer&amp;gt;(){
		{
			put(1, 31); put(2, 28); put(3, 31); put(4, 30);
			put(5, 31); put(6, 30); put(7, 31); put(8, 31);
			put(9, 30); put(10, 31); put(11, 30); put(12, 31);
		}
	};

	public static void main(String[] args) {
		MyData d = getNextData(getData());
		System.out.println(d.year+&quot;-&quot;+d.month+&quot;-&quot;+d.day);
	}

	public static MyData getNextData(MyData data) {
		data.day++;
		if (isLegalDay(data.month, data.day)) {
			return data;	
		} else {
			data.day = 1;
			data.month++;
			if (isLegalMonth(data.month)) {
				return data;
			} else {
				data.month = 1;
				data.year++;
				return data;
			}
		}
	}

	public static MyData getData() {
		// get input from keyboard
		Scanner s = new Scanner(System.in);
		// month/day/year
		String input = s.next();
		// using Regular Expression to verify input
		String pattern = &quot;^(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\\/(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))$&quot;;
		Matcher m = Pattern.compile(pattern).matcher(input);
		if (m.matches()) {
			String[] data = input.split(&quot;/&quot;);
			int year = Integer.parseInt(data[0]);
			int month = Integer.parseInt(data[1]);
			int day = Integer.parseInt(data[2]);
			if (isLeapYear(year)) {
				mapDay.put(2, 29);
			}
			if (isLegalYear(year) &amp;amp;&amp;amp; isLegalMonth(month) &amp;amp;&amp;amp; isLegalDay(month, day)) {
				MyData d = new MyData(year, month, day);
				return d;
			} else {
				System.out.println(&quot;your input is illegal!&quot;);
				System.exit(-1);
				return null;
			}
		} else {
			System.out.println(&quot;your input format is worry!&quot;);
			System.exit(-1);
			return null;
		}
	} 

	public static boolean isLegalYear(int year) {
		return year &amp;gt;= 1900 &amp;amp;&amp;amp; year &amp;lt; 3000;
	}

	public static boolean isLegalMonth(int month) {
		return month &amp;lt;= 12 &amp;amp;&amp;amp; month &amp;gt; 0;
	}

	public static boolean isLegalDay(int month, int day) {
		return mapDay.get(month).intValue() &amp;gt;= day;
	}

	public static boolean isLeapYear(int year) {
		return (year % 400 == 0) || (year % 4 == 0 &amp;amp;&amp;amp; year % 100 != 0);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>数组中只出现一次的数字</title>
        <link>https://sendoh-akira.github.io/2015/11/19/algorithm-hash.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/19/algorithm-hash.html</guid>
        <pubDate>Thu, 19 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在牛客上看到了很多这种题目 今天总结一下吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?rp=2&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot;&gt;题目&lt;/a&gt;很简单:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;题目描述
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。&lt;/p&gt;

  &lt;p&gt;时间限制：1秒空间限制：32768K
通过比例：21.19%
最佳记录：0 ms|8552K&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一开始看到这个题目的时候,很简单的想到了在OJ上做过的一道题目-&lt;a href=&quot;http://www.acmicpc.sdnu.edu.cn/problem/show/1106&quot;&gt;1106.字符统计器&lt;/a&gt;.这个题目的思路就是把字符当做一个索引,然后在对应的数组里面进行计数操作.所以这里我也想到了同样的方法,把每一个数字稻作一个Key,把他的个数当做Value来进行操作.代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
import java.util.HashMap;
import java.util.Map;
public class Solution {
	public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
		if (array.length == 0 || array.length == 1) {
			num2[0] = num1[0] = 0;
		}
		HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; array.length; i++) {
			if (map.containsKey(Integer.valueOf(array[i]))) {
				map.put(Integer.valueOf(array[i]), new Integer(2));
			} else {
				map.put(Integer.valueOf(array[i]), new Integer(1));
			}
		}
		boolean isOne = true;
		for (Map.Entry&amp;lt;Integer, Integer&amp;gt; m : map.entrySet()) {
			if (m.getValue().intValue() == 1) {
				if (isOne) {
					num1[0] = m.getKey().intValue();
					isOne = false;
				} else {
					num2[0] = m.getKey().intValue();
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提交没问题,但是看了一看排行榜,发现C++大神都是0time就通过了= =
然后看了一下人家的代码,发现他们用的完全和我不是一个思路,用的异或运算!一开始我是觉得好神奇的然后就学习了一下.先总结一下大家的思路都有哪些吧.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;比较简单粗暴的,挨个数据检索,没除了他以外的所有元素比较.这个很容易想到,但是时间复杂度是n^2.&lt;/li&gt;
  &lt;li&gt;先排序,然后在检索,这个复杂度主要看排序算法,最好也是nlgn,最坏n^2.&lt;/li&gt;
  &lt;li&gt;和我上面的思路一样,用数做key,然后计数,复杂度为n.&lt;/li&gt;
  &lt;li&gt;重点说一下异或运算这个方法.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实这个思路也很简单:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先,有一个理论基础,就是相等的两个数异或运算后得0;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们对所有的数据都进行异或运算,最后会的到一个不为0的数,这个数是那两个不相同的数(n1,n2)的异或得到的.姑且先把这个数想象成一个二进制的数,他必然有一位是1(假设这个位置是onePosition),这个1的位置处n1,n2必然有一个是1一个是0;当然,这个1的值都是由很多数据参与计算得到的结果,但是影响都是抵消的,所以这里我们再次运用这个结论,我们把onePosition上为1的归为一组,为0的归为一组.这样n1,n2就分别进入了这两个组里,我们再一次进行异或,就可以得到这两个数了.
代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
import java.util.HashMap;
import java.util.Map;
public class Solution {
	public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
		if (array.length == 0 || array.length == 1) {
			num2[0] = num1[0] = 0;
		}
	
		int sum = 0;
		for (int i = 0; i &amp;lt; array.length; i++) {
			sum ^= array[i];
		}

		int onePosition = 0;
		for (int i = 0; i &amp;lt; 32; i++) {
			if (((sum &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) {
				onePosition = i;
				break;
			}
		}

		for (int i = 0; i &amp;lt; array.length; i++) {
			if (((array[i] &amp;gt;&amp;gt; onePosition) &amp;amp; 1) == 1) {
				num1[0] ^= array[i];
			} else {
				num2[0] ^= array[i];
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>linux命令操作随记-不定时更新</title>
        <link>https://sendoh-akira.github.io/2015/11/15/linux-command.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/15/linux-command.html</guid>
        <pubDate>Sun, 15 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;使用linux的时候常常有些命令记不住 所以开一篇随时记录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;path&quot;&gt;1.如何添加path&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;2015年11月15日&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1.修改/etc/profile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/profile
//如果权限不够 请使用sudo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.修改path的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH = &quot;yourPathWantToBeSetted:$PATH&quot;
export PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.保存退出&lt;/p&gt;

&lt;p&gt;4.重启终端生效，或者使用source命令使其生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.验证&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $PATH //查看是否已经成功添加PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是我在按照上面的方法完成后还是只能一次终端生效，在开新的终端还是无效，于是我就尝试修改了一下&lt;code&gt;.bashrc&lt;/code&gt;,发现可以了。&lt;strong&gt;&lt;em&gt;注：我的系统是ubuntu-15.10&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//方法大体相同啦，稍微记录一下
//打开文件
vi .bashrc
//添加下面内容
export PATH=&quot;yourPathWantToBeSetted:$PATH&quot;
//esc : wq enter
//使其生效
source .bashrc
//验证
echo $PATH

//写一个shell放在目录下 就不会每次都add commit psuh了 一个命令同步博客 咩哈哈 爽~
/**
cd /home/jimbo/bornbeauty.github.io
git add -A
git commit -m &quot;addOrchange&quot;
git push
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是还有个小问题，就是commit里面有个参数，总是写那个敷衍的更新说明感觉很不爽，那就去看看shell参数好了～～～&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;符号&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当前脚本的文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$n&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$#&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的参数个数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的所有参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$@&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;上个命令的退出状态，或函数的返回值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;所以就很简单了，我们就用$n来获取参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /home/jimbo/bornbeauty.github.io
git add -A
git commit -m $1
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是问题又来了～有时候就是懒得不想写了怎么办！
好吧～判断一下是否为空吧～
&lt;a href=&quot;http://c.biancheng.net/cpp/view/7005.html&quot;&gt;shell选择语句语法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ condition ] //condition和[]必须间隔空格
	then
    	code
elif
	code
else
	code
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后的问题怎么判断为空呢？
&lt;a href=&quot;http://w55554.blog.51cto.com/947626/1223870&quot;&gt;shell怎么判断是否为空&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//最后代码变成了这个样子 试了试～ 挺好 开心
cd /home/jimbo/bornbeauty.github.io
git add -A
if [ $1 ]
	then
		git commit -m $1
else
	git commit -m &quot;changeOradd&quot;
fi

git push
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;section&quot;&gt;2.怎么移动复制文件&lt;/h6&gt;

&lt;p&gt;Linux下移动命令是mv（move的缩写），可以用来移动文件或者将文件改名。
命令格式：
mv [选项] 源文件或目录 目标文件或目录
命令参数：
-b ：若需覆盖文件，则覆盖前先行备份；
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖；
-u ：若目标文件已经存在，且 source 比较新，才会更新(update)。&lt;/p&gt;

&lt;p&gt;CP命令
格式: CP [选项]  源文件或目录   目的文件或目录
选项说明:-b 同名,备分原来的文件
-f 强制覆盖同名文件
-r  按递归方式保留原目录结构复制文件&lt;/p&gt;

&lt;h6 id=&quot;linux&quot;&gt;3.linux下的文件差异比较工具&lt;/h6&gt;

&lt;p&gt;diffuse&lt;/p&gt;

&lt;p&gt;安装方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install diffuse
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>简单的括号检查程序</title>
        <link>https://sendoh-akira.github.io/2015/11/09/java-comeputerTestHomework.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/09/java-comeputerTestHomework.html</guid>
        <pubDate>Mon, 09 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一个很简单的括号语法检查器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;&lt;em&gt;1.实现效果&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;首先我们先看一下我们实现的效果是什么样子的。
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/testHomework-1.png&quot; alt=&quot;&quot; /&gt;
我们要实现的功能如下，&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;检查代码中括号的使用是否合法&lt;/li&gt;
  &lt;li&gt;指出括号使用出现了什么错误&lt;/li&gt;
  &lt;li&gt;指出哪个括号出现了问题，在行中找出他的位置&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;&lt;strong&gt;&lt;em&gt;2.核心算法&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;核心算法&lt;/strong&gt;并不是很复杂，如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历整个字符串序列
    &lt;ul&gt;
      &lt;li&gt;若遇到左括号，如“（”和“{”，则将其入栈&lt;/li&gt;
      &lt;li&gt;若遇到右括号，如“）”和“}”，则获取到栈顶元素s
        &lt;ul&gt;
          &lt;li&gt;如果当前元素c与s是匹配的，则说明这里括号使用没有语法错误&lt;/li&gt;
          &lt;li&gt;如果当前元素c与s不匹配，则说明这里的括号使用有语法错误，需要记录错误信息&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;否则就不处理，直接跳过该元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;遍历结束后检查栈
    &lt;ul&gt;
      &lt;li&gt;如果栈为空，则说明没有语法错误&lt;/li&gt;
      &lt;li&gt;如果栈不为空，则说明有语法错误，需要记录错误信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;&lt;strong&gt;&lt;em&gt;3.思路分析&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;我们首先按照算法理一下思路：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;我们要获取到文件里的字符信息，这里就要用到文件读写的内容；我打算包装一个&lt;strong&gt;ReadFile&lt;/strong&gt;类，让他完成这些工作。&lt;/li&gt;
  &lt;li&gt;对于这个程序我们关心的数据有括号、括号所在行号、括号所在行的内容以及括号在行里的位置；把这些数据封装成实体类&lt;strong&gt;SymbolEntity&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;这检查过程中我们还需要产生错误信息，这个错误信息也需要包装成类&lt;strong&gt;ErrorDescription&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;最后就是最核心的检查功能了，我们把他封装成&lt;strong&gt;CheckUtil&lt;/strong&gt;类；这个类实现检测功能和错误信息生成功能；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;&lt;strong&gt;&lt;em&gt;4.具体实现&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;SymbolEntity.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;public class SymbolEntity {
	private String symbol;
	private int lineNumber;
	private String lineContent;
	private int symbolNumber;

	public SymbolEntity(String symbol, int lineNumber, String lineContent, int symbolNumber) {
		this.symbol = symbol;
		this.lineNumber = lineNumber;
		this.lineContent = lineContent;
		this.symbolNumber = symbolNumber;
	}

	public String getSymbol() {
		return symbol;
	}

	public int getLineNumber() {
		return lineNumber;
	}

	public String getLineContent() {
		return lineContent;
	}

	public int getSymbolNumber() {
		return symbolNumber;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;ErrorDescription.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; public class ErrorDescription {
	private int errorLineNumber;
	private String errorDes;

	public ErrorDescription() {
	}

	public ErrorDescription(int errorLineNumber, String errorDes) {
		this.errorLineNumber = errorLineNumber;
		this.errorDes = errorDes;
	}

	public int getErrorLineNumber() {
		return errorLineNumber;
	}

	public String getErrorDes() {
		return errorDes;
	}

	public void setErrorLineNumber(int errorLineNumber) {
		this.errorLineNumber = errorLineNumber;
	}

	public void setErrorDes() {
		this.errorDes = errorDes;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;CheckUtil.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.util.Stack;
import java.util.*;
import java.io.IOException;
//要注意在代码或者注释中出现的'{','}','(',')'，也会影响我们的判断
// {    123
// }   125
// (    40
// )    41

//故意出一个错误
// {
public class CheckUtil {
	private List&amp;lt;ErrorDescription&amp;gt; mErrorList = new ArrayList&amp;lt;&amp;gt;();
	private String mFileName;
	private ReadFile mReadFile;
	private Stack&amp;lt;SymbolEntity&amp;gt; mStack = new Stack();
	private boolean isOverCheck = false;

	public CheckUtil(ReadFile mReadFile) {
		this.mReadFile = mReadFile;
		mFileName = mReadFile.getFileName();
	}

	public CheckUtil(String mFileName) throws NullPointerException, Exception {
		this.mFileName = mFileName;
		mReadFile = new ReadFile(mFileName);
	}

	public boolean startCheck() throws IOException {

		String lineContent = &quot;&quot;;
	
		while(null != (lineContent = mReadFile.next())) {
			for (int i = 0; i &amp;lt; lineContent.length(); i++) {
				switch(lineContent.charAt(i)) {
					case 123: 
						mStack.push(new SymbolEntity(String.valueOf((char)123), 
						mReadFile.getLineNumber(),
						lineContent,
						i+1));
						break;
					case 40:
						mStack.push(new SymbolEntity(String.valueOf((char)40), 
						mReadFile.getLineNumber(),
						lineContent,
						i+1));
						break;
					case 125:
						dealChar((char)125, (char)123, lineContent, i+1);
						break;
					case 41:
						dealChar((char)41, (char)40, lineContent, i+1);
						break;
				}
			}
		}

		while (!mStack.isEmpty()) {
			SymbolEntity entity = mStack.pop();
			switch(entity.getSymbol().charAt(0)) {
				case 123:
					buildError(entity, (char)125);
					break;
				case 40:
					buildError(entity, (char)41);
					break;
			}
		}

		isOverCheck = true;
	
		if (0 == mErrorList.size()) {
			return true;
		} else {
			return false;
		}
	}

	private void dealChar(char currentChar, char oppositeSymbol, String lineContent, int symbolNumber) {

		if (!mStack.isEmpty()) {
			SymbolEntity entity = mStack.peek();
			if (entity.getSymbol().charAt(0) != oppositeSymbol) {
				buildError(new SymbolEntity(String.valueOf(currentChar), 
				mReadFile.getLineNumber(), lineContent, symbolNumber), oppositeSymbol);		
			} else {
				mStack.pop();
			}	
		} else {
			buildError(new SymbolEntity(String.valueOf(currentChar), 
				mReadFile.getLineNumber(), lineContent, symbolNumber), oppositeSymbol);	
		}
	}

	private void buildError(SymbolEntity entity, char missSymbol) {
		//在什么什么文件里，第多少多少行的什么没有什么与之配对
		String result = &quot;在&quot; + mFileName + &quot;中,&quot; + &quot;第&quot; + (entity.getLineNumber()+1) +
			&quot;行的\&quot;&quot; + entity.getSymbol() + &quot;\&quot;没有\&quot;&quot; + missSymbol + &quot;\&quot;与之配对\n&quot;
			+ entity.getLineContent() + &quot;\n&quot;;

		for (int i = 1; i &amp;lt; entity.getSymbolNumber(); i++) {
			result += &quot; &quot;;
		}

		result += &quot;^&quot;;

		mErrorList.add(new ErrorDescription(
				entity.getLineNumber(),
				result)
		);
	}	

	public boolean isChecked() {
		return isOverCheck;
	}

	public List&amp;lt;ErrorDescription&amp;gt; getErrorList() {
		if (isOverCheck) {
			return mErrorList;
		} else {
			return null;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;ReadFile.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.io.*;

public class ReadFile {
	//{
	private String mFileName;			// file path
	private int mCurrentLine = 0;			// current line number
	private BufferedReader mBufferReader;	// read file class

	public ReadFile() {
	}

	public ReadFile(String mFileName) throws NullPointerException,Exception {
		if (null == mFileName) {
			throw new NullPointerException(&quot;file name is not allowed to be null&quot;);
		}

		if (!(new File(mFileName).isFile())) {
			throw new Exception(&quot;this filename is not a file&quot;);
		}

		this.mFileName = mFileName;

		mBufferReader = new BufferedReader(new 
		FileReader(mFileName));
	}

	public String next() throws IOException {
		mCurrentLine++;
		return mBufferReader.readLine();
	}

	public int getLineNumber() {
		return mCurrentLine;
	}

	public String getFileName() {
		return mFileName;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Main.java类 该类就是来测试其他类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.util.*;
import java.io.*;
import java.util.regex.*;

public class Main{
	public static void main(String[] args) {
	
		File file = file = new File(&quot;.&quot;);
		final String regex = &quot;.java&quot;;
		String[] list = file.list(new FilenameFilter() {
			@Override
			public boolean accept(File file, String name) {
				return name.contains(regex);
			}
		});

		Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);
		String s = &quot;&quot;;
		List&amp;lt;ErrorDescription&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;();
		for (String name : list) {
			try {	
				//System.out.println(name);
				ReadFile r = new ReadFile(name);
				CheckUtil c = new CheckUtil(r);
				if (c.startCheck()) {
					System.out.println(name +&quot;:没有错误&quot;);
				} else {
					lists.addAll(c.getErrorList());
				}
			} catch(Exception e) {
				System.out.println(&quot;出现未捕获的异常，信息如下：&quot;);
				e.printStackTrace();
				System.exit(-1);
			}
		}
		for (ErrorDescription e : lists) {
			System.out.println(e.getErrorDes());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>2015年阅读书单</title>
        <link>https://sendoh-akira.github.io/2015/11/06/book-list-of-2015.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/06/book-list-of-2015.html</guid>
        <pubDate>Fri, 06 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;多挣钱 物质自由 多读书 精神自由&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
  </channel>
</rss>
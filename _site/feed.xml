<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>Sendoh Akira</title>
    <link>https://sendoh-akira.github.io</link>
    <description>good luck</description>
    
      <item>
        <title>Spring Interview Questions and Answers</title>
        <link>https://sendoh-akira.github.io/2016/09/22/java-interview_question_answer_spring.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/09/22/java-interview_question_answer_spring.html</guid>
        <pubDate>Thu, 22 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Spring面试题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;spring-core&quot;&gt;Spring Core&lt;/h1&gt;

&lt;p&gt;1.什么是Spring？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.Spring有哪些优点？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。

控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。

面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。

容器：Spring包含并管理应用程序对象的配置及生命周期。

MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。

事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。

异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.Spring框架有哪些模块？&lt;/p&gt;

&lt;p&gt;Spring框架的基本模块如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Core module
Bean module
Context module
Expression Language module
JDBC module
ORM module
OXM module
Java Messaging Service(JMS) module
Transaction module
Web module
Web-Servlet module
Web-Struts module
Web-Portlet module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.解释核心容器(应用上下文)模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.BeanFactory – BeanFactory 实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。
最常用的BeanFactory实现是XmlBeanFactory类。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.XmlBeanFactory&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.解释AOP模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.解释抽象JDBC和DAO模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.解释对象/关系映射集成模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.解释web模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11.解释Spring MVC模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;12.Spring的配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring的配置文件是一个XML文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;13.Spring IoC容器是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;14.IOC有什么优点？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15.应用上下文是如何实现的？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FileSystemXmlApplicationContext 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。
FileSystemXmlApplicationContext 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。
WebXmlApplicationContext：该容器加载xml文件，这些文件定义了web应用中所有的beans。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;16.Bean Factory和ApplicationContext有什么区别？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ApplicationContext提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。另外，容器或者容器中beans的操作，这些必须以bean工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了MessageSource，该接口用于获取本地消息，实际的实现是可选的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;17.Spring应用程序看起来像什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一个定义功能的接口

实现包括属性，setter和getter方法，功能等

Spring AOP

Spring的XML配置文件

使用该功能的客户端编程

依赖注入
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;18.Spring中的依赖注入是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。

依赖注入和控制反转

Dependency Injection 和 Inversion of Control 其实就是一个东西的两种不同的说法而已。本质上是一回事。Dependency Injection 是一个程序设计模式和架构模型， 一些时候也称作 Inversion of Control，尽管在技术上来讲，Dependency Injection 是一个 Inversion of Control 的特殊实现，Dependency Injection 是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个数据库连接以参数的形式传到一个对象的结构方法里面而不是在那个对象内部自行创建一个连接。Inversion of Control 和 Dependency Injection 的基本思想就是把类的依赖从类内部转化到外部以减少依赖。 应用Inversion of Control，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所以，Inversion of Control 是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;19.有哪些不同类型的IOC(依赖注入)？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。

Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;20.你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21.什么是Spring Beans？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。

在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;22.Spring Bean中定义了什么内容？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;23.如何向Spring 容器提供配置元数据？&lt;/p&gt;

&lt;p&gt;有三种方式向Spring 容器提供元数据:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XML配置文件

基于注解配置

基于Java的配置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;24.你如何定义bean的作用域？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候通过’scope’属性定义即可。例如，当Spring需要产生每次一个新的bean实例时，应该声明bean的scope属性为prototype。如果每次你希望Spring返回一个实例，应该声明bean的scope属性为singleton。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;25.说一下Spring中支持的bean作用域&lt;/p&gt;

&lt;p&gt;Spring框架支持如下五种不同的作用域：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;singleton：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。

prototype：一个bean可以定义多个实例。

request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。

session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境.

globalSession：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境.

bean默认的scope属性是’singleton‘。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;26.Spring框架中单例beans是线程安全的吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不是，Spring框架中的单例beans不是线程安全的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;27.解释Spring框架中bean的生命周期&lt;/p&gt;

&lt;p&gt;Spring容器读取XML文件中bean的定义并实例化bean。&lt;/p&gt;

&lt;p&gt;Spring根据bean的定义设置属性值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。

如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。

如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。

如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方。

如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。

如果该bean实现了DisposableBean，调用destroy()方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;28.哪些是最重要的bean生命周期方法？能重写它们吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;有两个重要的bean生命周期方法。第一个是setup方法，该方法在容器加载bean的时候被调用。第二个是teardown方法，该方法在bean从容器中移除的时候调用。

bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;29.什么是Spring的内部bean？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;30.如何在Spring中注入Java集合类？&lt;/p&gt;

&lt;p&gt;Spring提供如下几种类型的集合配置元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list元素用来注入一系列的值，允许有相同的值。

set元素用来注入一些列的值，不允许有相同的值。

map用来注入一组”键-值”对，键、值可以是任何类型的。

props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;31.什么是bean wiring？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;32.什么是bean自动装配？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和&amp;lt; property&amp;gt;元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;33.解释自动装配的各种模式？&lt;/p&gt;

&lt;p&gt;自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。

byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。

byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。

constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。

autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;34.自动装配有哪些局限性？&lt;/p&gt;

&lt;p&gt;自动装配有如下局限性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;重写：你仍然需要使用 和&amp;lt; property&amp;gt;设置指明依赖，这意味着总要重写自动装配。

原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。

模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;35.你可以在Spring中注入null或空字符串吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;完全可以。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;36.什么是Spring基于Java的配置？给出一些注解的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。

以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;37.什么是基于注解的容器配置?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;38.如何开启注解装配？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;39.@Required 注解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;40.@Autowired 注解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;41.@Qualifier 注解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;42.在Spring框架中如何更有效的使用JDBC？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate(例子)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;43.JdbcTemplate&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;44.Spring对DAO的支持&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;45.使用Spring可以通过什么方式访问Hibernate？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用Spring有两种方式访问Hibernate：

使用Hibernate Template的反转控制以及回调方法

继承HibernateDAOSupport，并申请一个AOP拦截器节点
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;46.Spring支持的ORM&lt;/p&gt;

&lt;p&gt;Spring支持以下ORM：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hibernate

iBatis

JPA (Java -Persistence API)

TopLink

JDO (Java Data Objects)

OJB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;47.如何通过HibernateDaoSupport将Spring和Hibernate结合起来？&lt;/p&gt;

&lt;p&gt;使用Spring的SessionFactory 调用LocalSessionFactory。结合过程分为以下三步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;配置Hibernate SessionFactory

继承HibernateDaoSupport实现一个DAO

使用AOP装载事务支持
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;48.Spring支持的事务管理类型&lt;/p&gt;

&lt;p&gt;Spring支持如下两种方式的事务管理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。

声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;49.Spring框架的事务管理有哪些优点？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。

它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).

它支持声明式事务管理。

它可以和Spring 的多种数据访问技术很好的融合。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;50.你更推荐那种类型的事务管理？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;springaop&quot;&gt;Spring面向切面编程(AOP)&lt;/h1&gt;

&lt;p&gt;51.解释AOP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;52.切面(Aspect)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;53.在Spring AOP中concern和 cross-cutting concern的区别是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。

Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;54.连接点(Join point)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;55.通知(Advice)&lt;/p&gt;

&lt;p&gt;通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。&lt;/p&gt;

&lt;p&gt;Spring切面可以执行一下五种类型的通知:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before(前置通知)：在一个方法之前执行的通知。

after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。

after-returning(后置通知)：在某连接点正常完成后执行的通知。

after-throwing(异常通知)：在方法抛出异常退出时执行的通知。

around(环绕通知)：在方法调用前后触发的通知。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;56.切入点(Pointcut)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;57.什么是引入？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;引入允许我们在已有的类上添加新的方法或属性。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;58.什么是目标对象？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;59.什么是代理？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;60.有几种不同类型的自动代理？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BeanNameAutoProxyCreator：bean名称自动代理创建器

DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器

Metadata autoproxying：元数据自动代理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;61.什么是织入？什么是织入应用的不同点？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;62.解释基于XML Schema方式的切面实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在这种情况下，切面由使用XML文件配置的类实现。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;63.解释基于注解方式(基于@AspectJ)的切面实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在这种情况下(基于@AspectJ的实现)，指的是切面的对应的类使用Java 5注解的声明方式。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;spring-web&quot;&gt;Spring Web&lt;/h1&gt;

&lt;p&gt;64.什么是Spring的MVC框架？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;65.DispatcherServlet&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;66.WebApplicationContext&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;67.什么是Spring MVC框架的控制器？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;68.@Controller annotation&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;69.@RequestMapping annotation&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;70.Spring 有多少个模块&lt;/p&gt;

&lt;p&gt;Spring Framework 的功能被组织成了 20 来个模块。这些模块分成&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Core Container,&lt;/li&gt;
  &lt;li&gt;Data Access/Integration,&lt;/li&gt;
  &lt;li&gt;Web,&lt;/li&gt;
  &lt;li&gt;AOP (Aspect Oriented Programming),&lt;/li&gt;
  &lt;li&gt;Instrumentation,&lt;/li&gt;
  &lt;li&gt;Messaging,&lt;/li&gt;
  &lt;li&gt;Test&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;71.使用场景&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Typical full-fledged Spring web application&lt;/li&gt;
  &lt;li&gt;Spring middle-tier using a third-party web framework&lt;/li&gt;
  &lt;li&gt;Remoting usage scenario&lt;/li&gt;
  &lt;li&gt;EJBs - Wrapping existing POJOs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;72.AOP是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aspect-Oriented Programming (面相切面编程 AOP) 用另外的一种编程架构的思考来补充 Object-Oriented Programming (面相对象编程OOP)。OOP 主要的模块单元是 class (类)，而 AOP 是 aspect（切面）。切面使得诸如事务管理等跨越多个类型和对象的关注点模块化。（这样的关注点在 AOP 的字眼里往往被称为 crosscutting （横切关注点））
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>jni使用详解</title>
        <link>https://sendoh-akira.github.io/2016/04/05/jni.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/04/05/jni.html</guid>
        <pubDate>Tue, 05 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;开发中难免要使用jni，现在系统的学习总结一下使用的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;jni&quot;&gt;1 jni概述&lt;/h5&gt;

&lt;p&gt;jni是Java Native Interface的缩写，中文译为“java本地方法接口”。通俗的说，jni是一种技术，通过jni你可以：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java程序中的函数可以调用Native语言写的函数，Native一般是指C/C++编写的代码。&lt;/li&gt;
  &lt;li&gt;Native程序中的函数可以调用Java层的函数，也就是说在C/C++程序中可以调用java的函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jnijni&quot;&gt;2 加载jni库以及注册jni函数&lt;/h5&gt;

&lt;p&gt;加载jni库非常简单，只需要在调用Native函数之前使用&lt;code&gt;System.loadLibrary(&quot;your_libray_name&quot;)&lt;/code&gt;即可。我们的通常做法是在class中的静态块中加载，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.jimbo.jni;

public class JNIInterface {

  static {
    System.loadLibrary(&quot;your_libray_name&quot;);
  }

  //这里可以定义你的Native函数
  public static native final void native_say_hello();

  int a;
  int b;
  public int calc() {
    return a+b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了&lt;code&gt;java&lt;/code&gt;代码编写的方法，那么问题来了，Native代码怎么编写呢？java函数怎么找到对应的Native函数呢？all right,让我们来看一下注册jni的两种方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;借助java的工具程序&lt;code&gt;javah&lt;/code&gt;来实现这一过程。答题流程是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编写java代码，然后编译生成&lt;code&gt;.class&lt;/code&gt;文件。&lt;/li&gt;
  &lt;li&gt;使用javah，例如&lt;code&gt;javah -o output packname.classname&lt;/code&gt;来生成一个叫做&lt;code&gt;output.h&lt;/code&gt;的头文件。&lt;/li&gt;
  &lt;li&gt;在jni层实现这些函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的&lt;code&gt;JNIInterface&lt;/code&gt;类经过上述操作后会得到这样的头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
//...省略
//注：如果java的函数中已经有了“_”，则&quot;_&quot;将会被替换成&quot;_l&quot;
JNIEXPORT void JNICALL Java_com_jimbo_jni_JNIInterface_native_lsay_lhello(JNIEnv *, jclass);

//...省略
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，这个Native函数的名字就是包名+函数名，只是因为“.”在c中有特殊的含义，所以被替换成了”_“。这个过程是这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当java层调用native_say_hello()函数时，他会从对应的JNI库中寻找Java_com_jimbo_jni_JNIInterface_native_lsay_lhello()函数，如果没有就会报错。如果找的到，则会为这个native_say_hello()和Java_com_jimbo_jni_JNIInterface_native_lsay_lhello()建立一个关联关系，其实就是保存jni层函数的函数指针。以后再调用native_say_hello()函数时，直接使用这个函数指针就可以了。当然这个过程是虚拟机来完成的，不需要我们操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;动态注册&lt;/p&gt;

    &lt;p&gt;既然java函数和native函数时一一对应的，那么是不是有一种结构来保存这些数据信息呢？答案是肯定的。在jni技术中，用一个&lt;code&gt;JNINativeMethod&lt;/code&gt;来保存，结构定义如下：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct {
  //java函数名 不用携带包名，待会会有其他方式提供包名，
  //这样查找起来效率就会更高
  const char *name;
  //函数签名信息，包括函数的参数以及函数的返回值等信息
  const char *signature;
  //函数指针，类型为void*
  void* fnptr;
} JNINativeMethod;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，这些对应数据什么时候会被加载出来了呢？其实在调用&lt;code&gt;System.loadLibrary(&quot;your_libray_name&quot;);&lt;/code&gt;之后，紧接着会查看该库中一个叫做&lt;code&gt;JNI_OnLoad()&lt;/code&gt;的函数，如果有就会调用它，动态注册就需要在这里完成。那么究竟如何实现这一个过程呢？需要调用两个函数就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jclass clazz = (*env) -&amp;gt; FindClass(env, className);

(*env) -&amp;gt; RegisterNatives(env, clazz, gMethods, numMethods);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体注册过程可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;string.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;assert.h&amp;gt;

//这个函数是对应java函数的
jstring native_say_hello(JNIEnv *env, jobject thiz) {
  return (*env) -&amp;gt; NewStringUTF(env, &quot;hello, i am from jni~&quot;);
}

//这个函数提供方法的对应信息，通过创建JNINativeMethod结构体来实现
//至于那么参数什么意思 待会具体说
static JNINativeMethod gMethods[] = {
  {&quot;native_say_hello&quot;, &quot;()Ljava/lang/String&quot;, (void)*native_say_hello},
}

//为类的某一个方法注册
static int registerNativeMethod(JNIEnv *env, const char* className, JNINativeMethod *gMethods, int numbers) {
  jclass  clazz = (*env) -&amp;gt; FindClass(env, className);
  if (null == clazz) {
    return JNI_FALSE;
  }
  if ((*env)-&amp;gt;RegisterNatives(env, clazz, gMethods, numMethods) &amp;lt; 0) {  
        return JNI_FALSE;  
  }
  return JNI_TURE;
}

//为所有类的方法注册
static int registerNatives(JNIEnv* env) {  
    const char* kClassName = &quot;com/jimbo/jni/JNIInterface&quot;;//指定要注册的类  
    return registerNativeMethods(env, kClassName, gMethods,  
            sizeof(gMethods) / sizeof(gMethods[0]));
}

//如果成功返回JNI版本, 失败返回-1
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {  
    JNIEnv* env = NULL;  

    if ((*vm)-&amp;gt;GetEnv(vm, (void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {  
        return -1;  
    }  
    assert(env != NULL);  

    if (!registerNatives(env)) {//注册  
        return -1;  
    }  
    //成功  
    return JNI_VERSION_1_4;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的方法我们就可以将jni函数和java的函数注册在一起了。但是上面代码似乎还是有点麻烦的，
其实jni的AndroidRunTime类提供了一个&lt;code&gt;registerNativeMethods()&lt;/code&gt;方法，可以更加简单的实现这
一过程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;string.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;assert.h&amp;gt;

jstring native_say_hello(JNIEnv *env, jobject thiz) {
  return (*env) -&amp;gt; NewStringUTF(env, &quot;hello, i am from jni~&quot;);
}

static JNINativeMethod gMethods[] = {
  {&quot;native_say_hello&quot;, &quot;()Ljava/lang/String;&quot;, (void)*native_say_hello},
}
//以上代码和前面是一样的

//如果成功返回JNI版本, 失败返回-1
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {  
    JNIEnv* env = NULL;   

    if ((*vm)-&amp;gt;GetEnv(vm, (void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {  
        return -1;  
    }  
    assert(env != NULL);  

    if (AndroidRunTime::registerNativeMethods(env, &quot;com/jimbo/jni/JNIInterface&quot;, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) &amp;lt; 0) {//注册  
        return -1;  
    }  
    //成功  
    return JNI_VERSION_1_4;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码比较好理解，但是JNINativeMethod中的signature可能会存在疑问。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&quot;()V&quot;
&quot;()I&quot;
&quot;(II)Ljava/lang/String&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上这些是与函数参数以及返回值一一对对应的。&lt;code&gt;()&lt;/code&gt;里面表示参数，&lt;code&gt;()&lt;/code&gt;外表示的函数的返回值。
比如&lt;code&gt;(II)Ljava/lang/String&lt;/code&gt;就对应这个函数&lt;code&gt;jstring functionName(int ,int)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;具体的对应关系如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;java类型&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;c类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;void&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;void&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jboolean&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;I&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jint&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jlong&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jdouble&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jfloat&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbyte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshort&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[I&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jintarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshortarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbytearray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jchararray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[S&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshortarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jdoublearray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[j&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jlongarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[z&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbooleanarray&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上是关于基本类型和基本类型的数组，那么类是如何表示的呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果Java函数的参数是class，则以”L”开头，以”;”结尾中间是用”/” 隔开的包及类名。而其对应的C函数名的参数则为jobject. 一个例外是String类，其对应的类为jstring
Ljava/lang/String; String jstring
Ljava/net/Socket; Socket jobject&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;jnienv&quot;&gt;3 JNIEnv介绍&lt;/h5&gt;

&lt;p&gt;JNIEnv，即JNIEnvironment，字面意思就是jni环境。其实他就是一个与线程相关的jni环境结构体。
JNIEnv提供了一些jni系统函数，通过这些函数我们可以做：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用java函数&lt;/li&gt;
  &lt;li&gt;操作jobject对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jnienvjobject&quot;&gt;4 通过JNIEnv操作jobject&lt;/h5&gt;

&lt;p&gt;我们都知道，类都是由方法和成员变量组成的，在jni的规则中，使用jfirldID和jMethod来表示java的
成员变量和方法，可通过jni下面的两个函数得到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jfieldId GetFieldID(jclass clazz, const char *name, const char *sig);
jMethod GetMethodID(jclass clazz, const char *name, const char *sig);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;jclass代表的java中的类，对应&lt;code&gt;java.lang.Class&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;第二个参数就是类的名称&lt;/li&gt;
  &lt;li&gt;第三个参数是函数签名，和前面介绍的一样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;得到jfieldId和jMethod后依然无法调用java函数。那到底该怎么做呢？
不着急，我们看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jint native_calc(JNIEnv *env, jobject thiz) {

  jclass clazz = env -&amp;gt; FindClass(&quot;com/jimbo/jni/JNIInterface&quot;);
  jmethodID java_calc_id = env -&amp;gt; GetMethodID(clazz, &quot;native_calc&quot;, &quot;()I&quot;);
  jfieldId a_id = env -&amp;gt; GetFieldID(clazz, &quot;a&quot;, &quot;I&quot;);
  jfieldId b_id = env -&amp;gt; GetFieldID(clazz, &quot;b&quot;, &quot;I&quot;);
  jint a = env -&amp;gt; GetIntField(clazz, thiz, a_id);
  jint b = env -&amp;gt; GetIntField(clazz, thiz, b_id);
  return env -&amp;gt; CallIntMethod(env, thiz, java_calc_id, a, b);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这段代码我们知道jni是通过&lt;code&gt;CallIntMethod()&lt;/code&gt;函数来调用了java的函数。&lt;/p&gt;

&lt;p&gt;实际上，jni有一系列类似的函数，形式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;//调用函数
//最后参数是调用函数的参数
NativeType Call&amp;lt;Type&amp;gt;Method(JNIEnv *env, jobject thiz, jmethodID methodID, ...);

//获取成员变量的值
NativeType Get&amp;lt;Type&amp;gt;Field(JNIEnv *env, jobject thiz, jfieldId fieldID);
//或者是
void Set&amp;lt;Typr&amp;gt;FieldID(JNIEnv *env, jobject thiz, jfieldId fieldID, NativeType value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用的还用如下函数:&lt;/p&gt;

&lt;p&gt;GetObjectField(),GetIntField(),GetShortField(),GetCharField()等等。&lt;/p&gt;

&lt;h5 id=&quot;jni-1&quot;&gt;5 jni的垃圾回收以及异常处理&lt;/h5&gt;

&lt;p&gt;在jni中，有三种类型的引用，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Local Reference：包括函数调用是传入的参数，在函数内创建的jobject。Local Reference
最大的特点就是，一旦jni函数结束，就会被回收。&lt;/li&gt;
  &lt;li&gt;Global Reference：全局引用，这种对象不主动释放永远都不会被回收。&lt;/li&gt;
  &lt;li&gt;Weak Reference：弱全局引用，在运行过程中可能被回收。所以在使用前要调用IsSameObject()
来判断他是否已经被回收了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在使用完变量后也可以通过&lt;code&gt;env -&amp;gt; Delete&amp;lt;ReferenceType&amp;gt;Ref&lt;/code&gt;来主动释放内存。例如DeleteLocalRef();&lt;/p&gt;

&lt;p&gt;在jni中，提供了三个函数来截获和处理异常：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ExceptionOccured(),用来判断时候发生了异常。&lt;/li&gt;
  &lt;li&gt;ExceptionClear(),用来清理jni层发生的异常。&lt;/li&gt;
  &lt;li&gt;ThrowNew(),用来向java层抛出异常。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文参考了&lt;a href=&quot;https://book.douban.com/subject/6802440/&quot;&gt;邓凡平的深入理解Android 卷1&lt;/a&gt;以及&lt;a href=&quot;http://blog.csdn.net/chenfeng0104/article/details/7088600&quot;&gt;chenfeng0104的专栏-动态注册JNI&lt;/a&gt;。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>二叉树的分层遍历</title>
        <link>https://sendoh-akira.github.io/2016/03/14/suanfa-erchashufencengbianli.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/03/14/suanfa-erchashufencengbianli.html</guid>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;二叉树的分层遍历&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;题目要求：给定一个二叉树的root结点，然后按照每层从左到右的顺序将二叉树结点的值储存在一个二维数组中，每一层一个数组，每一个数组的元素是按照从左到右的顺序进行存储的。&lt;/p&gt;

&lt;p&gt;思路：二叉树的分层打印类似于图的广度优先遍历算法，我们可以借助一个队列实现这个过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化队列 将root结点加入到队列之中&lt;/li&gt;
  &lt;li&gt;判断当前队列是否为空
    &lt;ul&gt;
      &lt;li&gt;不为空，则出队队列的首元素 并且将不为空的结点入队列&lt;/li&gt;
      &lt;li&gt;为空则表示遍历完成&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过上述操作之后就可以得到二叉树分层遍历的顺序了。但是我们并不能得到每一个层都有什么元素这样的信息，我们还需要在遍历的过程中使用变量记录这一个过程。&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;last&lt;/code&gt;变量记录当前打印行的最右结点&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;nLast&lt;/code&gt;变量记录加入队列的最近一个元素&lt;/p&gt;

&lt;p&gt;在元素弹出的时候判断一下是否和&lt;code&gt;last&lt;/code&gt;元素相等，相等则表示要换行了，这时候要更新&lt;code&gt;last&lt;/code&gt;的值，就是将&lt;code&gt;nLast&lt;/code&gt;赋值给&lt;code&gt;last&lt;/code&gt;即可，这样就实现了这个功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
import java.util.*;

public class Java {

	public static void main(String[] args) {
		TreeNode one = new TreeNode(1);
		TreeNode two = new TreeNode(2);
		TreeNode three =new TreeNode(3);
		TreeNode four = new TreeNode(4);
		TreeNode five = new TreeNode(5);
		TreeNode six = new TreeNode(6);
		TreeNode seven = new TreeNode(7);
		TreeNode eight = new TreeNode(8);
		TreeNode nine = new TreeNode(9);
		TreeNode ten = new TreeNode(10);
		TreeNode n11 = new TreeNode(11);
		TreeNode n12 = new TreeNode(12);
		TreeNode n13 = new TreeNode(13);
		TreeNode n14 = new TreeNode(14);

		one.left = two;
		one.right = three;
		//two.left = four;
		two.right = five;
		three.left = six;
		three.right = seven;
		four.left = eight;
		//four.right = nine;
		//five.left = ten;
		five.right = n11;
		six.left = n12;
		six.right = n13;

		n13.right = n14;

		TreePrinter p = new TreePrinter();
		int[][] result = p.printTree(one);
		for (int i = 0; i &amp;lt; result.length; i++) {
			for (int j = 0; j &amp;lt; result[i].length; j++) {
				System.out.print(result[i][j]);
			}
			System.out.println(&quot;&quot;);
		}
	}

}

class TreePrinter {
    public int[][] printTree(TreeNode root) {
        // write code here
    	if (null == root) {
    		return null;
    	}

    	if (null == root.left &amp;amp;&amp;amp; null == root.right) {
    		int[][] result = ;
    		return result;
    	}

    	int[][] result = new int[10][];

    	Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;();	
    	TreeNode last = root;
    	TreeNode nLast = root.right == null ? root.left : root.right;

    	int i = 0;
    	int j = 0;

    	int numOfLine[] = new int[10];

    	result[i] = new int[1];

    	queue.add(root);

    	while(!queue.isEmpty()) {

    		TreeNode tree = queue.poll();
    		result[i][j++] = tree.val;
    		numOfLine[i]++;

    		if (tree.left != null) {
    			queue.add(tree.left);
    			nLast = tree.left;
    		}
    		if (tree.right != null) {
    			queue.add(tree.right);
    			nLast = tree.right;
    		}

    		if (last == tree) {
    			j = 0;
    			i++;
    			result[i] = new int[(int)(Math.pow((double)2, (double)i))];
    			last = nLast;
    		}

    		
    	}

    	int[][] r = new int[i][];
    	//System.out.println(i+&quot;&quot;);
    	for (int g = 0; g &amp;lt; i; g++) {
    		r[g] = new int[numOfLine[g]];
    		for (int h = 0; h &amp;lt; numOfLine[g]; h++) {
    			r[g][h] = result[g][h];
    		}
    	}
    	result = null;
    	return r;
    }
}

class TreeNode {
    public int val = 0;
    public TreeNode left = null;
    public TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}


&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>upsdnu使用说明</title>
        <link>https://sendoh-akira.github.io/2015/12/02/life-upsdnudescription.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/12/02/life-upsdnudescription.html</guid>
        <pubDate>Wed, 02 Dec 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;upsdnu使用说明
任何意见以及建议都可以反馈 在博客下面留言即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;BUG集合：
2016年3月15日20:58:09&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;由于采用thread去请求认证 可能会导致内存泄露问题&lt;/li&gt;
    &lt;li&gt;
      &lt;h2 id=&quot;section&quot;&gt;计算绩点操作数据的时候可能导致了精度丢失&lt;/h2&gt;
      &lt;p&gt;1.alpha_2.1 2016年1月6日16:46:29：(尚未处理)
java.lang.StringIndexOutOfBoundsException: length=0; regionStart=1; regionLength=-2
at java.lang.String.startEndAndLength(String.java:504)
at java.lang.String.substring(String.java:1333)
at com.jimbo.myapplication.MainActivity.getWifiName(MainActivity.java:315)
可能是WIFI的名字过长溢出了
2.alpha_2.0 2016年1月6日16:56:12: (已经处理)
at android.view.ViewRootImpl.setView(ViewRootImpl.java:677)
at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:248)
at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)
at android.app.Dialog.show(Dialog.java:281)
at com.gc.materialdesign.widgets.SnackBar.show(SnackBar.java:93)
可能是因为activity被切换到后台导致的问题&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-1&quot;&gt;1. 使用说明&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;SDNU WIFI连接模块
1.首先在菜单选项里面找到&lt;code&gt;设置sdnu账号&lt;/code&gt;
2.进入设置账号
3.在首页即可使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：软件没有任务后台服务，只会在网络状态改变的时候被激活(重启手机后没有打开过或者被强制关闭过软件不会被激活)，并且连接后完全释放资源。由于sdnu网络环境比较复杂，并不能保证每一次都能自动连接到网络，没有接收到通知的时候可以手动启动软件连接。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;成绩查询模块
1.在菜单选项里面找到&lt;code&gt;本学期成绩&lt;/code&gt;和&lt;code&gt;计算绩点&lt;/code&gt;
2.进入输入教务处&lt;code&gt;学号&lt;/code&gt;和&lt;code&gt;密码&lt;/code&gt;即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：这是我见过最丑的界面= =&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;2. 关于&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.如果有意见请在下面留言或者发送邮件到 zhongjinbao1994@gmail.com，欢迎大家反馈
2.代码开源 不会窃取用户信息
3.唯一指定软件下载地址 &lt;a href=&quot;http://www.pgyer.com/upsdun&quot;&gt;upsdnu-蒲公英&lt;/a&gt;，不要相信其他途径，防止被钓鱼。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-3&quot;&gt;3. 软件部分截图&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot.jpg&quot; alt=&quot;截图2&quot; /&gt;
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot1_meitu_2.jpg&quot; alt=&quot;截图3&quot; /&gt;
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot2_meitu_3.jpg&quot; alt=&quot;截图1&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>为什么使用sudo命令执行sh会报command not found错误</title>
        <link>https://sendoh-akira.github.io/2015/11/22/linux-sduoshcommandnotfound.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/22/linux-sduoshcommandnotfound.html</guid>
        <pubDate>Sun, 22 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;明明sh文件存在,为什么还会说命令找不到呢?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/poechant/article/details/7216892&quot;&gt;参考博客-Linux下执行一些命令前加sudo时出现command not found的原因&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了科(翻)学(墙)上网,一直在用&lt;a href=&quot;www.laod.cn&quot;&gt;laod&lt;/a&gt;给的hosts,非常感谢!为了能高效的更换hosts,想用sh来完成.由于涉及了系统文件的操作,所以需要使用sudo来用root权限执行.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo changehosts.sh
sudo:changehosts.sh 找不到命令
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是输出PATH看了一下,路径设置是没问题的.只好请教万能的&lt;a href=&quot;www.google.com&quot;&gt;google&lt;/a&gt;,终于找到了答案.&lt;/p&gt;

&lt;p&gt;原来,在Linux下用sudo执行某一命令时,是在原进程(parent process)的基础上fork出来一个子进程(child process),这个子进程是以root权限执行的.然后在子进程中,执行你在sudo后面跟的命令.在子进程中是无法调用涉及到父进程的状态的一些命令的,所以非系统内置命令会被拒绝.这就是为什么会出现command not found的提示.
原因找到了,但是文中没有给解决办法.
那我们该怎么办呢?
我们可以用&lt;code&gt;su - root&lt;/code&gt;开启root账号,然后执行完在退出.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su - root
密码:
root@username:#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行完我们发现我们已经取得了root权限,这时候执行准没错了.
但是令人失望的是还是找不到命令,这又是怎么了?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $PTAH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出发现没有我们设置的shell路径了,恍然大悟,我们已经切换到了root账号下面,设置也已经变了.这样的话我们只要先进入预先的目录然后在执行,ok,成功.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>计算nextDay的实现</title>
        <link>https://sendoh-akira.github.io/2015/11/22/java-nextday.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/22/java-nextday.html</guid>
        <pubDate>Sun, 22 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;实现nextDay算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;1.题目要求&lt;/h2&gt;

&lt;p&gt;用户从键盘输入”2014/11/11”,然后输出该输入的下一天日期是多少.
要求很简单,看上去也不是很复杂,但是要考虑到闰年,月份进位等等问题.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.思路分析&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;用户输入合法性问题&lt;/li&gt;
  &lt;li&gt;nextDay的推算算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们先看第一个问题:
这个比较简单,我们可以使用正则表达式来匹配用户的输入,当然了,只是正则表达式可能还无法完全约束合法,我们可以继续针对个别的在正确的校验.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//使用分隔符'/'分割年月日
//年份可以使用09或者2009这样的形式 月份使用1或者01 日使用01或者1
//至少有一位 至多有两位
//则可以得到下面的匹配规则
String pattern = &quot;^(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\\/(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))$&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样,就可以得到一个合法的类似于”2013/14/22”这样的字符串,但是我们发现,14月仍然是不合法的,仍需我们再次校验合法性.于是,可以封装三个函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isLegalYear(int year) {
	return year &amp;gt;= 1900 &amp;amp;&amp;amp; year &amp;lt; 3000;
}

public static boolean isLegalMonth(int month) {
	return month &amp;lt;= 12 &amp;amp;&amp;amp; month &amp;gt; 0;
}

public static boolean isLegalDay(int month, int day) {
	return mapDay.get(month).intValue() &amp;gt;= day;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样,我们就可以得到一个正确合法的输入日期,然后就可以依照算法,计算下一天.&lt;/p&gt;

&lt;p&gt;再看第二个问题:
算法说起来也比较简单,类似于一个加法器,只是各个位置上的进位法则不一样而已.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将day自加1
    &lt;ul&gt;
      &lt;li&gt;若day合法,返回该data&lt;/li&gt;
      &lt;li&gt;若day不合法,day赋值为1,month自加1
        &lt;ul&gt;
          &lt;li&gt;若month合法,返回该data&lt;/li&gt;
          &lt;li&gt;若month不合法,month赋值为1,year自加,返回data&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过上述算法计算,即可得到正确的日期了.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.具体实现&lt;/h2&gt;

&lt;p&gt;首先封装一个data数据类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyData {
	public MyData(int year, int month, int day) {
		this.day = day;
		this.month = month;
		this.year = year;
	}
	public int year;
	public int month;
	public int day;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import java.util.*;
import java.util.regex.*;

public class NextDay{

	public static Map&amp;lt;Integer, Integer&amp;gt; mapDay = new HashMap&amp;lt;Integer, Integer&amp;gt;(){
		{
			put(1, 31); put(2, 28); put(3, 31); put(4, 30);
			put(5, 31); put(6, 30); put(7, 31); put(8, 31);
			put(9, 30); put(10, 31); put(11, 30); put(12, 31);
		}
	};

	public static void main(String[] args) {
		MyData d = getNextData(getData());
		System.out.println(d.year+&quot;-&quot;+d.month+&quot;-&quot;+d.day);
	}

	public static MyData getNextData(MyData data) {
		data.day++;
		if (isLegalDay(data.month, data.day)) {
			return data;	
		} else {
			data.day = 1;
			data.month++;
			if (isLegalMonth(data.month)) {
				return data;
			} else {
				data.month = 1;
				data.year++;
				return data;
			}
		}
	}

	public static MyData getData() {
		// get input from keyboard
		Scanner s = new Scanner(System.in);
		// month/day/year
		String input = s.next();
		// using Regular Expression to verify input
		String pattern = &quot;^(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\\/(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))$&quot;;
		Matcher m = Pattern.compile(pattern).matcher(input);
		if (m.matches()) {
			String[] data = input.split(&quot;/&quot;);
			int year = Integer.parseInt(data[0]);
			int month = Integer.parseInt(data[1]);
			int day = Integer.parseInt(data[2]);
			if (isLeapYear(year)) {
				mapDay.put(2, 29);
			}
			if (isLegalYear(year) &amp;amp;&amp;amp; isLegalMonth(month) &amp;amp;&amp;amp; isLegalDay(month, day)) {
				MyData d = new MyData(year, month, day);
				return d;
			} else {
				System.out.println(&quot;your input is illegal!&quot;);
				System.exit(-1);
				return null;
			}
		} else {
			System.out.println(&quot;your input format is worry!&quot;);
			System.exit(-1);
			return null;
		}
	} 

	public static boolean isLegalYear(int year) {
		return year &amp;gt;= 1900 &amp;amp;&amp;amp; year &amp;lt; 3000;
	}

	public static boolean isLegalMonth(int month) {
		return month &amp;lt;= 12 &amp;amp;&amp;amp; month &amp;gt; 0;
	}

	public static boolean isLegalDay(int month, int day) {
		return mapDay.get(month).intValue() &amp;gt;= day;
	}

	public static boolean isLeapYear(int year) {
		return (year % 400 == 0) || (year % 4 == 0 &amp;amp;&amp;amp; year % 100 != 0);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>数组中只出现一次的数字</title>
        <link>https://sendoh-akira.github.io/2015/11/19/algorithm-hash.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/19/algorithm-hash.html</guid>
        <pubDate>Thu, 19 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在牛客上看到了很多这种题目 今天总结一下吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?rp=2&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot;&gt;题目&lt;/a&gt;很简单:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;题目描述
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。&lt;/p&gt;

  &lt;p&gt;时间限制：1秒空间限制：32768K
通过比例：21.19%
最佳记录：0 ms|8552K&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一开始看到这个题目的时候,很简单的想到了在OJ上做过的一道题目-&lt;a href=&quot;http://www.acmicpc.sdnu.edu.cn/problem/show/1106&quot;&gt;1106.字符统计器&lt;/a&gt;.这个题目的思路就是把字符当做一个索引,然后在对应的数组里面进行计数操作.所以这里我也想到了同样的方法,把每一个数字稻作一个Key,把他的个数当做Value来进行操作.代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
import java.util.HashMap;
import java.util.Map;
public class Solution {
	public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
		if (array.length == 0 || array.length == 1) {
			num2[0] = num1[0] = 0;
		}
		HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; array.length; i++) {
			if (map.containsKey(Integer.valueOf(array[i]))) {
				map.put(Integer.valueOf(array[i]), new Integer(2));
			} else {
				map.put(Integer.valueOf(array[i]), new Integer(1));
			}
		}
		boolean isOne = true;
		for (Map.Entry&amp;lt;Integer, Integer&amp;gt; m : map.entrySet()) {
			if (m.getValue().intValue() == 1) {
				if (isOne) {
					num1[0] = m.getKey().intValue();
					isOne = false;
				} else {
					num2[0] = m.getKey().intValue();
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提交没问题,但是看了一看排行榜,发现C++大神都是0time就通过了= =
然后看了一下人家的代码,发现他们用的完全和我不是一个思路,用的异或运算!一开始我是觉得好神奇的然后就学习了一下.先总结一下大家的思路都有哪些吧.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;比较简单粗暴的,挨个数据检索,没除了他以外的所有元素比较.这个很容易想到,但是时间复杂度是n^2.&lt;/li&gt;
  &lt;li&gt;先排序,然后在检索,这个复杂度主要看排序算法,最好也是nlgn,最坏n^2.&lt;/li&gt;
  &lt;li&gt;和我上面的思路一样,用数做key,然后计数,复杂度为n.&lt;/li&gt;
  &lt;li&gt;重点说一下异或运算这个方法.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实这个思路也很简单:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先,有一个理论基础,就是相等的两个数异或运算后得0;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们对所有的数据都进行异或运算,最后会的到一个不为0的数,这个数是那两个不相同的数(n1,n2)的异或得到的.姑且先把这个数想象成一个二进制的数,他必然有一位是1(假设这个位置是onePosition),这个1的位置处n1,n2必然有一个是1一个是0;当然,这个1的值都是由很多数据参与计算得到的结果,但是影响都是抵消的,所以这里我们再次运用这个结论,我们把onePosition上为1的归为一组,为0的归为一组.这样n1,n2就分别进入了这两个组里,我们再一次进行异或,就可以得到这两个数了.
代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
import java.util.HashMap;
import java.util.Map;
public class Solution {
	public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
		if (array.length == 0 || array.length == 1) {
			num2[0] = num1[0] = 0;
		}
	
		int sum = 0;
		for (int i = 0; i &amp;lt; array.length; i++) {
			sum ^= array[i];
		}

		int onePosition = 0;
		for (int i = 0; i &amp;lt; 32; i++) {
			if (((sum &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) {
				onePosition = i;
				break;
			}
		}

		for (int i = 0; i &amp;lt; array.length; i++) {
			if (((array[i] &amp;gt;&amp;gt; onePosition) &amp;amp; 1) == 1) {
				num1[0] ^= array[i];
			} else {
				num2[0] ^= array[i];
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>linux命令操作随记-不定时更新</title>
        <link>https://sendoh-akira.github.io/2015/11/15/linux-command.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/15/linux-command.html</guid>
        <pubDate>Sun, 15 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;使用linux的时候常常有些命令记不住 所以开一篇随时记录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;path&quot;&gt;1.如何添加path&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;2015年11月15日&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1.修改/etc/profile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/profile
//如果权限不够 请使用sudo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.修改path的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH = &quot;yourPathWantToBeSetted:$PATH&quot;
export PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.保存退出&lt;/p&gt;

&lt;p&gt;4.重启终端生效，或者使用source命令使其生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.验证&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $PATH //查看是否已经成功添加PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是我在按照上面的方法完成后还是只能一次终端生效，在开新的终端还是无效，于是我就尝试修改了一下&lt;code&gt;.bashrc&lt;/code&gt;,发现可以了。&lt;strong&gt;&lt;em&gt;注：我的系统是ubuntu-15.10&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//方法大体相同啦，稍微记录一下
//打开文件
vi .bashrc
//添加下面内容
export PATH=&quot;yourPathWantToBeSetted:$PATH&quot;
//esc : wq enter
//使其生效
source .bashrc
//验证
echo $PATH

//写一个shell放在目录下 就不会每次都add commit psuh了 一个命令同步博客 咩哈哈 爽~
/**
cd /home/jimbo/bornbeauty.github.io
git add -A
git commit -m &quot;addOrchange&quot;
git push
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是还有个小问题，就是commit里面有个参数，总是写那个敷衍的更新说明感觉很不爽，那就去看看shell参数好了～～～&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;符号&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当前脚本的文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$n&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$#&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的参数个数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的所有参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$@&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;上个命令的退出状态，或函数的返回值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;所以就很简单了，我们就用$n来获取参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /home/jimbo/bornbeauty.github.io
git add -A
git commit -m $1
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是问题又来了～有时候就是懒得不想写了怎么办！
好吧～判断一下是否为空吧～
&lt;a href=&quot;http://c.biancheng.net/cpp/view/7005.html&quot;&gt;shell选择语句语法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ condition ] //condition和[]必须间隔空格
	then
    	code
elif
	code
else
	code
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后的问题怎么判断为空呢？
&lt;a href=&quot;http://w55554.blog.51cto.com/947626/1223870&quot;&gt;shell怎么判断是否为空&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//最后代码变成了这个样子 试了试～ 挺好 开心
cd /home/jimbo/bornbeauty.github.io
git add -A
if [ $1 ]
	then
		git commit -m $1
else
	git commit -m &quot;changeOradd&quot;
fi

git push
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;section&quot;&gt;2.怎么移动复制文件&lt;/h6&gt;

&lt;p&gt;Linux下移动命令是mv（move的缩写），可以用来移动文件或者将文件改名。
命令格式：
mv [选项] 源文件或目录 目标文件或目录
命令参数：
-b ：若需覆盖文件，则覆盖前先行备份；
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖；
-u ：若目标文件已经存在，且 source 比较新，才会更新(update)。&lt;/p&gt;

&lt;p&gt;CP命令
格式: CP [选项]  源文件或目录   目的文件或目录
选项说明:-b 同名,备分原来的文件
-f 强制覆盖同名文件
-r  按递归方式保留原目录结构复制文件&lt;/p&gt;

&lt;h6 id=&quot;linux&quot;&gt;3.linux下的文件差异比较工具&lt;/h6&gt;

&lt;p&gt;diffuse&lt;/p&gt;

&lt;p&gt;安装方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install diffuse
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>简单的括号检查程序</title>
        <link>https://sendoh-akira.github.io/2015/11/09/java-comeputerTestHomework.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/09/java-comeputerTestHomework.html</guid>
        <pubDate>Mon, 09 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一个很简单的括号语法检查器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;&lt;em&gt;1.实现效果&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;首先我们先看一下我们实现的效果是什么样子的。
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/testHomework-1.png&quot; alt=&quot;&quot; /&gt;
我们要实现的功能如下，&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;检查代码中括号的使用是否合法&lt;/li&gt;
  &lt;li&gt;指出括号使用出现了什么错误&lt;/li&gt;
  &lt;li&gt;指出哪个括号出现了问题，在行中找出他的位置&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;&lt;strong&gt;&lt;em&gt;2.核心算法&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;核心算法&lt;/strong&gt;并不是很复杂，如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历整个字符串序列
    &lt;ul&gt;
      &lt;li&gt;若遇到左括号，如“（”和“{”，则将其入栈&lt;/li&gt;
      &lt;li&gt;若遇到右括号，如“）”和“}”，则获取到栈顶元素s
        &lt;ul&gt;
          &lt;li&gt;如果当前元素c与s是匹配的，则说明这里括号使用没有语法错误&lt;/li&gt;
          &lt;li&gt;如果当前元素c与s不匹配，则说明这里的括号使用有语法错误，需要记录错误信息&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;否则就不处理，直接跳过该元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;遍历结束后检查栈
    &lt;ul&gt;
      &lt;li&gt;如果栈为空，则说明没有语法错误&lt;/li&gt;
      &lt;li&gt;如果栈不为空，则说明有语法错误，需要记录错误信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;&lt;strong&gt;&lt;em&gt;3.思路分析&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;我们首先按照算法理一下思路：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;我们要获取到文件里的字符信息，这里就要用到文件读写的内容；我打算包装一个&lt;strong&gt;ReadFile&lt;/strong&gt;类，让他完成这些工作。&lt;/li&gt;
  &lt;li&gt;对于这个程序我们关心的数据有括号、括号所在行号、括号所在行的内容以及括号在行里的位置；把这些数据封装成实体类&lt;strong&gt;SymbolEntity&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;这检查过程中我们还需要产生错误信息，这个错误信息也需要包装成类&lt;strong&gt;ErrorDescription&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;最后就是最核心的检查功能了，我们把他封装成&lt;strong&gt;CheckUtil&lt;/strong&gt;类；这个类实现检测功能和错误信息生成功能；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;&lt;strong&gt;&lt;em&gt;4.具体实现&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;SymbolEntity.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;public class SymbolEntity {
	private String symbol;
	private int lineNumber;
	private String lineContent;
	private int symbolNumber;

	public SymbolEntity(String symbol, int lineNumber, String lineContent, int symbolNumber) {
		this.symbol = symbol;
		this.lineNumber = lineNumber;
		this.lineContent = lineContent;
		this.symbolNumber = symbolNumber;
	}

	public String getSymbol() {
		return symbol;
	}

	public int getLineNumber() {
		return lineNumber;
	}

	public String getLineContent() {
		return lineContent;
	}

	public int getSymbolNumber() {
		return symbolNumber;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;ErrorDescription.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; public class ErrorDescription {
	private int errorLineNumber;
	private String errorDes;

	public ErrorDescription() {
	}

	public ErrorDescription(int errorLineNumber, String errorDes) {
		this.errorLineNumber = errorLineNumber;
		this.errorDes = errorDes;
	}

	public int getErrorLineNumber() {
		return errorLineNumber;
	}

	public String getErrorDes() {
		return errorDes;
	}

	public void setErrorLineNumber(int errorLineNumber) {
		this.errorLineNumber = errorLineNumber;
	}

	public void setErrorDes() {
		this.errorDes = errorDes;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;CheckUtil.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.util.Stack;
import java.util.*;
import java.io.IOException;
//要注意在代码或者注释中出现的'{','}','(',')'，也会影响我们的判断
// {    123
// }   125
// (    40
// )    41

//故意出一个错误
// {
public class CheckUtil {
	private List&amp;lt;ErrorDescription&amp;gt; mErrorList = new ArrayList&amp;lt;&amp;gt;();
	private String mFileName;
	private ReadFile mReadFile;
	private Stack&amp;lt;SymbolEntity&amp;gt; mStack = new Stack();
	private boolean isOverCheck = false;

	public CheckUtil(ReadFile mReadFile) {
		this.mReadFile = mReadFile;
		mFileName = mReadFile.getFileName();
	}

	public CheckUtil(String mFileName) throws NullPointerException, Exception {
		this.mFileName = mFileName;
		mReadFile = new ReadFile(mFileName);
	}

	public boolean startCheck() throws IOException {

		String lineContent = &quot;&quot;;
	
		while(null != (lineContent = mReadFile.next())) {
			for (int i = 0; i &amp;lt; lineContent.length(); i++) {
				switch(lineContent.charAt(i)) {
					case 123: 
						mStack.push(new SymbolEntity(String.valueOf((char)123), 
						mReadFile.getLineNumber(),
						lineContent,
						i+1));
						break;
					case 40:
						mStack.push(new SymbolEntity(String.valueOf((char)40), 
						mReadFile.getLineNumber(),
						lineContent,
						i+1));
						break;
					case 125:
						dealChar((char)125, (char)123, lineContent, i+1);
						break;
					case 41:
						dealChar((char)41, (char)40, lineContent, i+1);
						break;
				}
			}
		}

		while (!mStack.isEmpty()) {
			SymbolEntity entity = mStack.pop();
			switch(entity.getSymbol().charAt(0)) {
				case 123:
					buildError(entity, (char)125);
					break;
				case 40:
					buildError(entity, (char)41);
					break;
			}
		}

		isOverCheck = true;
	
		if (0 == mErrorList.size()) {
			return true;
		} else {
			return false;
		}
	}

	private void dealChar(char currentChar, char oppositeSymbol, String lineContent, int symbolNumber) {

		if (!mStack.isEmpty()) {
			SymbolEntity entity = mStack.peek();
			if (entity.getSymbol().charAt(0) != oppositeSymbol) {
				buildError(new SymbolEntity(String.valueOf(currentChar), 
				mReadFile.getLineNumber(), lineContent, symbolNumber), oppositeSymbol);		
			} else {
				mStack.pop();
			}	
		} else {
			buildError(new SymbolEntity(String.valueOf(currentChar), 
				mReadFile.getLineNumber(), lineContent, symbolNumber), oppositeSymbol);	
		}
	}

	private void buildError(SymbolEntity entity, char missSymbol) {
		//在什么什么文件里，第多少多少行的什么没有什么与之配对
		String result = &quot;在&quot; + mFileName + &quot;中,&quot; + &quot;第&quot; + (entity.getLineNumber()+1) +
			&quot;行的\&quot;&quot; + entity.getSymbol() + &quot;\&quot;没有\&quot;&quot; + missSymbol + &quot;\&quot;与之配对\n&quot;
			+ entity.getLineContent() + &quot;\n&quot;;

		for (int i = 1; i &amp;lt; entity.getSymbolNumber(); i++) {
			result += &quot; &quot;;
		}

		result += &quot;^&quot;;

		mErrorList.add(new ErrorDescription(
				entity.getLineNumber(),
				result)
		);
	}	

	public boolean isChecked() {
		return isOverCheck;
	}

	public List&amp;lt;ErrorDescription&amp;gt; getErrorList() {
		if (isOverCheck) {
			return mErrorList;
		} else {
			return null;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;ReadFile.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.io.*;

public class ReadFile {
	//{
	private String mFileName;			// file path
	private int mCurrentLine = 0;			// current line number
	private BufferedReader mBufferReader;	// read file class

	public ReadFile() {
	}

	public ReadFile(String mFileName) throws NullPointerException,Exception {
		if (null == mFileName) {
			throw new NullPointerException(&quot;file name is not allowed to be null&quot;);
		}

		if (!(new File(mFileName).isFile())) {
			throw new Exception(&quot;this filename is not a file&quot;);
		}

		this.mFileName = mFileName;

		mBufferReader = new BufferedReader(new 
		FileReader(mFileName));
	}

	public String next() throws IOException {
		mCurrentLine++;
		return mBufferReader.readLine();
	}

	public int getLineNumber() {
		return mCurrentLine;
	}

	public String getFileName() {
		return mFileName;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Main.java类 该类就是来测试其他类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.util.*;
import java.io.*;
import java.util.regex.*;

public class Main{
	public static void main(String[] args) {
	
		File file = file = new File(&quot;.&quot;);
		final String regex = &quot;.java&quot;;
		String[] list = file.list(new FilenameFilter() {
			@Override
			public boolean accept(File file, String name) {
				return name.contains(regex);
			}
		});

		Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);
		String s = &quot;&quot;;
		List&amp;lt;ErrorDescription&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;();
		for (String name : list) {
			try {	
				//System.out.println(name);
				ReadFile r = new ReadFile(name);
				CheckUtil c = new CheckUtil(r);
				if (c.startCheck()) {
					System.out.println(name +&quot;:没有错误&quot;);
				} else {
					lists.addAll(c.getErrorList());
				}
			} catch(Exception e) {
				System.out.println(&quot;出现未捕获的异常，信息如下：&quot;);
				e.printStackTrace();
				System.exit(-1);
			}
		}
		for (ErrorDescription e : lists) {
			System.out.println(e.getErrorDes());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>2015年阅读书单</title>
        <link>https://sendoh-akira.github.io/2015/11/06/book-list-of-2015.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/06/book-list-of-2015.html</guid>
        <pubDate>Fri, 06 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;多挣钱 物质自由 多读书 精神自由&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
  </channel>
</rss>
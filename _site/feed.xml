<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>Sendoh</title>
    <link>https://sendoh-akira.github.io</link>
    <description></description>
    
      <item>
        <title>cdh重启步骤</title>
        <link>https://sendoh-akira.github.io/2017/09/01/cdh%E9%87%8D%E5%90%AF%E6%AD%A5%E9%AA%A4.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2017/09/01/cdh%E9%87%8D%E5%90%AF%E6%AD%A5%E9%AA%A4.html</guid>
        <pubDate>Fri, 01 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;cdh重启步骤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;ntp&quot;&gt;ntp服务启动&lt;/h1&gt;

&lt;p&gt;在master、node1、node2、node3上分别执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable ntpd
systemctl start ntpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在master上执行 date 查看时间，如果和北京时间差距很多，需要重置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;date -s &quot;2017-03-06 10:25:25&quot;
clock -w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在node1、node2上分别执行同步命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ntpdate -u  master
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;rpc&quot;&gt;rpc服务启动&lt;/h1&gt;

&lt;p&gt;在master、node1、node2、node3上分别执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#启动rpc服务
service rpcbind start
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;cloudera-manager-serveragent&quot;&gt;启动Cloudera Manager Server和agent&lt;/h1&gt;

&lt;p&gt;在master上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#启动server
/opt/cm-5.9.0/etc/init.d/cloudera-scm-server start
#启动agent
/opt/cm-5.9.0/etc/init.d/cloudera-scm-agent start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在slave上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#启动agent
/opt/cm-5.9.0/etc/init.d/cloudera-scm-agent start
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;kerberos&quot;&gt;启动kerberos&lt;/h1&gt;

&lt;p&gt;在node3(主节点)上启动kerberos kdc：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service krb5kdc start
service kadmin start
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;redissentinel&quot;&gt;启动redis和sentinel&lt;/h1&gt;

&lt;p&gt;node1(主节点)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#redis server
redis-server ./redis.conf
#redis-sentinel
redis-sentinel ./sentinel.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;node2(从节点)，node3(从节点):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#redis server
redis-server ./redis.conf
#redis-sentinel
redis-sentinel ./sentinel.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;es&quot;&gt;启动ES&lt;/h1&gt;

&lt;p&gt;在node1、node2、node3上&lt;/p&gt;

&lt;p&gt;切到es用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su - es
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入elasticsearch-5.2.1/目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd elasticsearch-5.2.1/
cd bin
#后台启动
./elasticsearch -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动kibana(在node1节点)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd kibana-5.2.1-linux-x86_64/
cd bin
./kibana
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在浏览器中访问http://192.168.1.201:5601即可，账号和密码分别为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;elastic  changeme
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Hbase 协处理器部署</title>
        <link>https://sendoh-akira.github.io/2017/09/01/Hbase%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E9%83%A8%E7%BD%B2.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2017/09/01/Hbase%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E9%83%A8%E7%BD%B2.html</guid>
        <pubDate>Fri, 01 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Hbase 协处理器部署&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;jar&quot;&gt;将写好的协处理器代码打jar包&lt;/h1&gt;

&lt;p&gt;在项目中pom文件中加入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;build&amp;gt;
      &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
      &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;configuration&amp;gt;
        &amp;lt;descriptorRefs&amp;gt;
      &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt;
        &amp;lt;/descriptorRefs&amp;gt;
        &amp;lt;archive&amp;gt;
          &amp;lt;manifest&amp;gt;
            &amp;lt;mainClass&amp;gt;watchfile.WatchFile&amp;lt;/mainClass&amp;gt;
          &amp;lt;/manifest&amp;gt;
        &amp;lt;/archive&amp;gt;
      &amp;lt;/configuration&amp;gt;
      &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
          &amp;lt;id&amp;gt;make-assembly&amp;lt;/id&amp;gt;
          &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
          &amp;lt;goals&amp;gt;
            &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
          &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
      &amp;lt;/executions&amp;gt;
    &amp;lt;/plugin&amp;gt;
      &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行maven打包命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn clean package
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;jarjarhdfs&quot;&gt;将打好包的协处理器jar（包含依赖包的jar）上传到hdfs&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;hdfs dfs -put dybdp-coprocessor-1.0.0.jar /user/dybdp/
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;jar-1&quot;&gt;修改jar文件权限&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;hhadoop fs -setfacl -m user:hbase:rwx /user/dybdp/dybdp-coprocessor-1.0.0.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;dybdpco&quot;&gt;给表dybdp_co添加协处理器&lt;/h1&gt;

&lt;p&gt;进入habase&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disable dybdp_co
alter 'dybdp_co' , METHOD =&amp;gt; 'table_att', 'coprocessor' =&amp;gt; ' hdfs://nameservice1/user/dybdp/dybdp-coprocessor-1.0.0.jar|com.dybdp.es.coprocessor.HbaseEsIndexCoprocesser|1002'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;coprocessor的值是一个字符串，由以下几个部分组成：
jar地址（如果在配置文件中定义了CLASS_PATH可以不填）|类名（包含包路径）|优先级|自定义属性&lt;/p&gt;

&lt;h1 id=&quot;dybdpco-1&quot;&gt;启用表dybdp_co&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;enable dybdp_co
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>HA 安装配置</title>
        <link>https://sendoh-akira.github.io/2017/09/01/HA%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2017/09/01/HA%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</guid>
        <pubDate>Fri, 01 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Elasticsearch HA 安装配置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;selinux&quot;&gt;关闭SElinux、配置防火墙&lt;/h1&gt;

&lt;p&gt;修改selinux&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/selinux/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#SELINUXTYPE=targeted
SELINUX=disabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使配置立即生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setenforce 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改防火墙&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/sysconfig/iptables

#允许组播地址通信
-A RH-Firewall-1-INPUT -d 224.0.0.18 -j ACCEPT
#允许VRRP（虚拟路由器冗余协）通信
-A RH-Firewall-1-INPUT -p    vrrp    -j ACCEPT
#允许80端口通过防火墙
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启防火墙使配置生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/iptables restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;haproxy&quot;&gt;安装HAProxy&lt;/h1&gt;

&lt;p&gt;创建HAProxy运行账户和组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#添加haproxy组
groupadd haproxy
useradd -g haproxy haproxy -s /bin/false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#创建nginx运行账户haproxy并加入到haproxy组，不允许haproxy用户直接登录系统。&lt;/p&gt;

&lt;p&gt;安装gcc组件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install -y gcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压下载好的haproxy-1.6.9.tar.gz包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf haproxy-1.6.9.tar.gz

cd haproxy-1.6.9

#编译  uname -r #查看系统内核版本号
make TARGET=linux3100 CPU=x86_64  PREFIX=/usr/local/haprpxy

#安装
make install PREFIX=/usr/local/haproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#TARGET=linux3100
#使用uname -r查看内核，如：2.6.18-371.el5，此时该参数就为linux26
#kernel 大于2.6.28的用：TARGET=linux2628
#CPU=x86_64   #使用uname -r查看系统信息，如x86_64 x86_64 x86_64 	GNU/Linux，此时该参数就为x86_64
#PREFIX=/usr/local/haprpxy  #/usr/local/haprpxy为haprpxy安装路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置HAProxy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#创建配置文件目录
mkdir -p  /usr/local/haproxy/conf

#创建配置文件目录
mkdir -p /etc/haproxy
#创建配置文件
touch  /usr/local/haproxy/conf/haproxy.cfg

#添加配置文件软连接
ln -s  /usr/local/haproxy/conf/haproxy.cfg   /etc/haproxy/haproxy.cfg

#拷贝错误页面
cp  -r  /usr/local/src/haproxy-1.6.9/examples/errorfiles  /usr/local/haproxy/errorfiles

#添加软连接
ln -s  /usr/local/haproxy/errorfiles  /etc/haproxy/errorfiles

#创建日志文件目录
mkdir -p  /usr/local/haproxy/log
#创建日志文件
touch  /usr/local/haproxy/log/haproxy.log
#添加软连接
ln -s  /usr/local/haproxy/log/haproxy.log  /var/log/haproxy.log
#拷贝开机启动文件
cp /usr/local/src/haproxy-1.6.9/examples/haproxy.init  /etc/rc.d/init.d/haproxy

#添加脚本执行权限
chmod +x  /etc/rc.d/init.d/haproxy
#设置开机启动
chkconfig haproxy on
#添加软连接
ln -s  /usr/local/haproxy/sbin/haproxy  /usr/sbin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置haproxy.cfg参数&lt;/p&gt;

&lt;p&gt;备份
    cp /usr/local/haproxy/conf/haproxy.cfg /usr/local/haproxy/conf/haproxy.cfg-bak&lt;/p&gt;

&lt;p&gt;内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi  /usr/local/haproxy/conf/haproxy.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置HAProxy日志&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    daemon
    nbproc 1
    pidfile /var/run/haproxy.pid
    ulimit-n 65535

defaults
    mode tcp                        #mode { tcp|http|health }，tcp 表示4层，http表示7层，health仅作为健康检查使用
    retries 2                       #尝试2次失败则从集群摘除
    option redispatch               #如果失效则强制转换其他服务器
    option abortonclose             #连接数过大自动关闭
    maxconn 1024                    #最大连接数
    timeout connect 1d              #连接超时时间，重要，hive查询数据能返回结果的保证
    timeout client 1d               #同上
    timeout server 1d               #同上
    timeout check 2000              #健康检查时间
    log 127.0.0.1 local0 err #[err warning info debug]

listen  admin_stats                     #定义管理界面
    bind 0.0.0.0:1090               #管理界面访问IP和端口
    mode http                       #管理界面所使用的协议
    maxconn 10          #最大连接数
    stats refresh 30s               #30秒自动刷新
    stats uri /                     #访问url
    stats realm Hive\ Haproxy       #验证窗口提示
    stats auth admin:123456         #401验证用户名密码

listen hive             #hive后端定义
    bind 0.0.0.0:10001              #ha作为proxy所绑定的IP和端口
    mode tcp                        #以4层方式代理，重要
    balance leastconn               #调度算法 'leastconn' 最少连接数分配，或者 'roundrobin'，轮询分配
    maxconn 1024                    #最大连接数
    server node1 192.168.1.201:10000 check inter 180000 rise 1 fall 2
    server node2 192.168.1.202:10000 check inter 180000 rise 1 fall 2
#释义：server 主机代名(你自己能看懂就行)，IP:端口 每180000毫秒检查一次。也就是三分钟。
#hive每有10000端口的请求就会创建一个log，设置短了，/tmp下面会有无数个log文件，删不完。

listen oozie             #oozie后端定义
    bind 0.0.0.0:11100              #ha作为proxy所绑定的IP和端口
    mode tcp                        #以4层方式代理，重要
    balance leastconn               #调度算法 'leastconn' 最少连接数分配，或者 'roundrobin'，轮询分配
    maxconn 1024                    #最大连接数
    server node1 192.168.1.201:11000 check inter 180000 rise 1 fall 2
    server node2 192.168.1.202:11000 check inter 180000 rise 1 fall 2
#释义：server 主机代名(你自己能看懂就行)，IP:端口 每180000毫秒检查一次。也就是三分钟。
#oozie每有11001端口的请求就会创建一个log，设置短了，/tmp下面会有无数个log文件，删不完。


listen impala             #impala后端定义
    bind 0.0.0.0:21051              #ha作为proxy所绑定的IP和端口
    mode tcp                        #以4层方式代理，重要
    balance leastconn               #调度算法 'leastconn' 最少连接数分配，或者 'roundrobin'，轮询分配
    maxconn 1024                    #最大连接数
    server node1 192.168.1.201:21050 check inter 180000 rise 1 fall 2
    server node2 192.168.1.202:21050 check inter 180000 rise 1 fall 2
    server node3 192.168.1.203:21050 check inter 180000 rise 1 fall 2
#释义：server 主机代名(你自己能看懂就行)，IP:端口 每180000毫秒检查一次。也就是三分钟。
#impala每有11001端口的请求就会创建一个log，设置短了，/tmp下面会有无数个log文件，删不完。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;haproxy命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#启动
service haproxy stop  

#关闭
service haproxy start

#重启
service haproxy restart  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑，在最下边增加
    vi  /etc/syslog.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# haproxy.log
local0.*          /var/log/haproxy.log
local3.*          /var/log/haproxy.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi  /etc/sysconfig/syslog

#接收远程服务器日志
SYSLOGD_OPTIONS=&quot;-r -m 0&quot;
#重启syslog  
service syslog restart  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器打开haproxy的监控页面&lt;/p&gt;

&lt;p&gt;如下：&lt;/p&gt;

&lt;p&gt;http://ip:1090/stats  //说明：1090即haproxy配置文件中监听端口，stats 即haproxy配置文件中的监听名称&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Elasticsearch 插件安装</title>
        <link>https://sendoh-akira.github.io/2017/09/01/Elasticsearch%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2017/09/01/Elasticsearch%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.html</guid>
        <pubDate>Fri, 01 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Elasticsearch 插件安装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;x-pack&quot;&gt;安装安全插件x-pack&lt;/h1&gt;

&lt;p&gt;安装插件命令&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在线安装&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;   bin/elasticsearch-plugin install x-pack
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;离线安装&lt;/p&gt;

    &lt;p&gt;下载安装包&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; https://artifacts.elastic.co/downloads/packs/x-pack/x-pack-5.2.1.zip
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后放在/home/es目录下。进入bin目录&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cd  /home/es/elasticsearch-5.2.1/bin
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后执行&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ./elasticsearch-plugin install /home/es/x-pack-5.2.1.zip
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;默认用户名密码为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;elastic:changeme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除插件命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/elasticsearch-plugin remove x-pack
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;kibana&quot;&gt;kibana安装（图形化界面组件）&lt;/h1&gt;

&lt;p&gt;下载kibana-5.2.1-linux-x86_64.tar.gz，然后放置在/home/es&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget kibana-5.2.1-linux-x86_64.tar.gz
mv kibana-5.2.1-linux-x86_64.tar.gz /home/es
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用es用户进行解压&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -zxvf  kibana-5.2.1-linux-x86_64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改kibana.yml配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi  /home/es/kibana-5.2.1-linux-x86_64/config/kibana.yml

#解开注解并修改：
server.host: &quot;192.168.1.211&quot;
#解开注解并修改：
#elasticsearch.url: &quot;http://192.168.1.211:9200&quot;
#解开注解并修改：
elasticsearch.username: &quot;elastic&quot;
elasticsearch.password: &quot;changeme&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入kibana安装目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /home/es/kibana-5.2.1-linux-x86_64/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行，安装x-pack组件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./kibana-plugin install file:///home/es/x-pack-5.2.1.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动kibana&lt;/p&gt;

&lt;p&gt;先启动ES&lt;/p&gt;

&lt;p&gt;首先进入bin目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /home/es/kibana-5.2.1-linux-x86_64/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./kibana
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证&lt;/p&gt;

&lt;p&gt;在浏览器上输入：http://192.168.1.211:5601/ 可以打开Kibana，此时需要输入用户名和密码登录，默认分别是 elastic 和 changeme&lt;/p&gt;

&lt;h1 id=&quot;elasearchik&quot;&gt;Elasearch安装IK分词器&lt;/h1&gt;

&lt;p&gt;下载地址&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik&quot;&gt;https://github.com/medcl/elasticsearch-analysis-ik&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在windows下解压到当前文件夹，首先查看pom文件版本号，修改为与es匹配的版本&lt;/p&gt;

&lt;p&gt;如5.2.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;elasticsearch.version&amp;gt;5.2.1&amp;lt;/elasticsearch.version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在文件夹内右键此处打开命令窗口，输出命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn clean package
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果电脑没有安装maven，可以把下载的ik项目导入eclipse里进行打包。
eclipse-import &amp;gt; maven project &amp;gt; –修改jre环境为jdk环境&lt;/p&gt;

&lt;p&gt;打包成功以后，会生成一个target文件夹(可以在控制台窗口显示target包所在目录)，找到elasticsearch-analysis-ik-5.2.1.zip，这就是我们需要的安装文件。&lt;/p&gt;

&lt;p&gt;将elasticsearch-analysis-ik-5.2.1.zip上传到/home/es/elasticsearch-5.2.1/plugins目录下，然后进入plugins目录下&lt;/p&gt;

&lt;p&gt;修改文件夹权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chown es:es elasticsearch-analysis-ik-5.2.1.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换成es用户，进行解压unzip elasticsearch-analysis-ik-5.2.1.zip 生成一个elasticsearch文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su -es  

unzip elasticsearch-analysis-ik-5.2.1.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重命名为ik&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv elasticsearch ik
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后删除elasticsearch-analysis-ik-5.2.1.zip压缩包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -rf elasticsearch-analysis-ik-5.2.1.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置分词器&lt;/p&gt;

&lt;p&gt;更改配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi elasticsearch-5.2.1/plugins/analysis-ik/config/IKAnalyzer.cfg.xml

#配置内容
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&amp;gt;
&amp;lt;properties&amp;gt;
        &amp;lt;comment&amp;gt;IK Analyzer 扩展配置&amp;lt;/comment&amp;gt;
        &amp;lt;!--用户可以在这里配置自己的扩展字典 --&amp;gt;
        &amp;lt;entrykey=&quot;ext_dict&quot;&amp;gt; custom/mydict.dic;custom/sougou.dic;custom/single_word_low_freq.dicen&amp;lt;/entrykey&amp;gt;
        &amp;lt;!--用户可以在这里配置自己的扩展停止词字典--&amp;gt;
        &amp;lt;entry key=&quot;ext_stopwords&quot;&amp;gt;custom/ext_stopword.dic&amp;lt;/entry&amp;gt;
        &amp;lt;!--用户可以在这里配置远程扩展字典 --&amp;gt;
        &amp;lt;!-- &amp;lt;entry key=&quot;remote_ext_dict&quot;&amp;gt;words_location&amp;lt;/entry&amp;gt; --&amp;gt;
        &amp;lt;!--用户可以在这里配置远程扩展停止词字典--&amp;gt;
        &amp;lt;!-- &amp;lt;entry key=&quot;remote_ext_stopwords&quot;&amp;gt;words_location&amp;lt;/entry&amp;gt; --&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Elasticsearch 安装</title>
        <link>https://sendoh-akira.github.io/2017/09/01/Elasticsearch%E5%AE%89%E8%A3%85.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2017/09/01/Elasticsearch%E5%AE%89%E8%A3%85.html</guid>
        <pubDate>Fri, 01 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Elasticsearch 安装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;安装环境概述&lt;/h1&gt;

&lt;p&gt;3台机器部署：
  node1:192.168.1.201
  node2:192.168.1.202
  node3:192.168.1.203
  jdk8、es5.2.1、kibana5.2.1、x-pack、ik&lt;/p&gt;

&lt;p&gt;node1、node2、node3都需要安装&lt;/p&gt;

&lt;h1 id=&quot;root&quot;&gt;创建或使用已有的非root用户&lt;/h1&gt;

&lt;p&gt;Es只能以非root用户启用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;useradd es
passwd  es
#回车输入密码
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;root-1&quot;&gt;使用root用户登录&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;su - root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改文件/etc/sysctl.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/sysctl.conf

#在文件末尾处添加
vm.max_map_count=655360
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生效并查看是否更改成功（此步骤必须执行，才可以刷新sysctl.conf生效）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sysctl -p

#显示以下内容表示更改成功
vm.max_map_count = 262144
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改文件/etc/security/limits.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/security/limits.conf

#在文件末尾处添加 * 为匹配所有用户
* hard nofile 65536
* soft nofile 131072
* soft nproc 2048
* hard nproc 4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后用es用户登录查看是否成功&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ulimit -Hn

#输出以下内容标识修改成功
65536
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用es用户登录解压 elasticsearch-5.1.1.tar.gz&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar –zxvf elasticsearch-5.1.1.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;注意：解压过程中每个es会生成一个uuid，所以不要scp拷贝，这样uuid一样会出问题，每台机器要分开解压&lt;/font&gt;

&lt;p&gt;修改Es配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi  /opt/elasticsearch/config/elasticsearch.yml

#此机器elasticsearch节点名称，各机器不能重复
cluster.name: es-cluster

#本机ip
network.host: 192.168.1.203  

#各个机器的名称
node.name: node1

#数据存放目录（可修改）  
path.data: /home/es/elasticsearch-5.2.1/data

#日志存放目录（可修改）  
path.logs: /home/es/elasticsearch-5.2.1/logs

bootstrap.memory_lock: false

#(此项如果没有则添加上)
bootstrap.system_call_filter: false

#设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点(配置两个，三个都可以)
discovery.zen.ping.unicast.hosts: [&quot;192.168.1.201&quot;, &quot;192.168.1.202&quot;]

#设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4）  
discovery.zen.minimum_master_nodes: 2

#(不需要配置)
http.cors.enabled: true
#(不需要配置)
http.cors.allow-origin: &quot;*&quot;

action.auto_create_index: .security,.monitoring*,.watches,.triggered_watches,.watcher-history*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改jvm.options ，看机器配置，越大越好，默认为2g&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi  /home/es/elasticsearch-5.2.1/config/jvm.options

-Xms256m
-Xmx256m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改90-nproc.conf(需要使用root用户进行修改)
注：该目录下也可能是20-nproc.conf这个文件，名字不固定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/security/limits.d/90-nproc.conf

# * soft nproc 1024 改为 soft nproc 2048
* soft nproc 2048
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动Es&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd elasticsearch/bin

./elasticsearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考文档&lt;/p&gt;

&lt;p&gt;Es java api&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/java-search.html&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/java-search.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;es分页&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sojson.com/blog/90.html&quot;&gt;http://www.sojson.com/blog/90.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;x-pack 安全&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/x-pack/current/_how_authentication_works.html&quot;&gt;https://www.elastic.co/guide/en/x-pack/current/_how_authentication_works.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;esik分词器&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/fenglailea/article/details/55506775&quot;&gt;http://blog.csdn.net/fenglailea/article/details/55506775&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;es 高亮&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lu_wei_wei/article/details/51055209&quot;&gt;http://blog.csdn.net/lu_wei_wei/article/details/51055209&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>在linux下安装mysql</title>
        <link>https://sendoh-akira.github.io/2017/08/31/linux%E5%AE%89%E8%A3%85mysql.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2017/08/31/linux%E5%AE%89%E8%A3%85mysql.html</guid>
        <pubDate>Thu, 31 Aug 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在linux下进行安装mysql server&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;安装前准备&lt;/h1&gt;

&lt;p&gt;MySQL 依赖 libaio,所以先要安装 libaio
yum-based systems:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# search for info
yum search libaio
# install library
yum install libaio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;APT-based systems:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# search for info
apt-cache search libaio
# install library
apt-get install libaio
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;yum&quot;&gt;使用yum库在线安装&lt;/h1&gt;

&lt;p&gt;MySQL 提供了一个Yum格式的软件库可以在Linux平台发现:&lt;/p&gt;

&lt;p&gt;EL5, EL6, and EL7-based platforms (for example, the corresponding versions of Red Hat Enterprise Linux, Oracle Linux, and CentOS) Fedora 23 and 24&lt;/p&gt;

&lt;h2 id=&quot;mysql-yum-&quot;&gt;添加 MySQL Yum 库&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;MySQL Server Yum 库主页 (http://dev.mysql.com/downloads/repo/yum/) in the MySQL Developer Zone.&lt;/li&gt;
  &lt;li&gt;选择并下载对应系统库到本地&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过命令安装&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo yum localinstall platform-and-version-specific-package-name.rpm
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;EL6-based system:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo yum localinstall mysql57-community-release-el6-{version-number}.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;EL7-based system:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo yum localinstall mysql57-community-release-el7-{version-number}.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;EL5-based system:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo rpm -Uvh mysql57-community-release-el5-{version-number}.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;检查是否安装成功
    &lt;pre&gt;&lt;code&gt;yum repolist enabled | grep &quot;mysql.*-community.*&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;选择发布版本的库&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看可用版本&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; yum repolist all | grep mysql
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持yum-config-manager&lt;/p&gt;

    &lt;p&gt;选择要启用/停用的mysql服务&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo yum-config-manager --disable mysql57-community
 sudo yum-config-manager --enable mysql56-community
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;或者修改配置文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi /etc/yum.repos.d/mysql-community.repo
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;停用：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; enabled=0 disable
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;启用：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; enabled=1 enable
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;安装mysql5.7yum库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mysql57-community]

 name=MySQL 5.7 Community Server baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/
 enabled=1

 gpgcheck=1

 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;安装mysql5.6 yum库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #Enable to use MySQL 5.6
 [mysql56-community]

 name=MySQL 5.6 Community Server
 baseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/
 enabled=1

 gpgcheck=1
 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;检查生效的库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; yum repolist enabled | grep mysql
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装MySQL&lt;/p&gt;

    &lt;p&gt;安装MySQL&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo yum install mysql-community-server
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动MySQL Server&lt;/p&gt;

    &lt;p&gt;启动MySQL Server&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo service mysqld start
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;启动成功输出结果：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Starting mysqld:[ OK ]
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;检查MySQL server 状态&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo service mysqld status
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;检查MySQL server 状态输出结果&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysqld (pid 3066) is running.
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;安全策略
	&lt;code&gt;
	mysql_secure_installation
	&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;忘记密码处理&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;进入mysql安装目录&lt;/p&gt;

    &lt;p&gt;5.7以后使用authentication_string
 Update mysql.user set authentication_string=password(‘root’) where user=’root’ ;
 FLUSH PRIVILEGES;&lt;/p&gt;

    &lt;p&gt;抛出警告信息
 Your password does not satisfy the current policy requirements&lt;/p&gt;

    &lt;p&gt;关闭安全策略&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi /etc/my.cnf  
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;末尾追加&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; validate_password = OFF
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;安全模式下修改密码&lt;/p&gt;

    &lt;p&gt;安全模式下启动服务&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ./bin/mysqld_safe   --user=root --skip-grant-tables &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;进入mysql,修改密码
     mysql -u root
     mysql -u root&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; UPDATE mysql.user SET Password = PASSWORD('new_password')  WHERE User = 'root';

 FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用mysqladmin&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; shell&amp;gt; mysqladmin -u root password &quot;new_password&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;初始化数据库&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;找到mysql安装目录，这里引用使用MYSQL_HOME&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cd $MYSQL_HOME
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;改变文件夹权限修改文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; chown -R mysql .
 chgrp -R mysql .
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化数据库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; scripts/mysql_install_db --user=mysql
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;可指定安装选项&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; scripts/mysql_install_db --user=mysql \ --basedir=/usr/local/apps/mysql \ --datadir=/usr/local/apps/mysql/data
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;mysqlinstalldb 选项&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Format&lt;/td&gt;
          &lt;td&gt;Description&lt;/td&gt;
          &lt;td&gt;Introduced&lt;/td&gt;
          &lt;td&gt;Deprecated&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–basedir&lt;/td&gt;
          &lt;td&gt;Path to base directory&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–builddir&lt;/td&gt;
          &lt;td&gt;Path to build directory (for out-of-source builds)&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–cross-bootstrap&lt;/td&gt;
          &lt;td&gt;For internal use&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–datadir&lt;/td&gt;
          &lt;td&gt;Path to data directory&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–defaults-extra-file&lt;/td&gt;
          &lt;td&gt;Read named option file in addition to usual option files&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–defaults-file&lt;/td&gt;
          &lt;td&gt;Read only named option file&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–force&lt;/td&gt;
          &lt;td&gt;Run even if DNS does not work&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–help&lt;/td&gt;
          &lt;td&gt;Display help message and exit&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–keep-my-cnf&lt;/td&gt;
          &lt;td&gt;Keep existing my.cnf file, do not create new one&lt;/td&gt;
          &lt;td&gt;5.6.20&lt;/td&gt;
          &lt;td&gt;5.6.20&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–ldata&lt;/td&gt;
          &lt;td&gt;Synonym for –datadir&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–no-defaults&lt;/td&gt;
          &lt;td&gt;Read no option files&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–random-passwords&lt;/td&gt;
          &lt;td&gt;Generate administrative account random password&lt;/td&gt;
          &lt;td&gt;5.6.8&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–rpm&lt;/td&gt;
          &lt;td&gt;For internal use&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–skip-name-resolve&lt;/td&gt;
          &lt;td&gt;Use IP addresses rather than host names in grant tables&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–srcdir&lt;/td&gt;
          &lt;td&gt;For internal use&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–user&lt;/td&gt;
          &lt;td&gt;System login user under which to execute mysqld&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–verbose&lt;/td&gt;
          &lt;td&gt;Verbose mode&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–windows&lt;/td&gt;
          &lt;td&gt;For internal use&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置最终文件权限&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; chown -R root .
 chown -R mysql data
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动配置&lt;/p&gt;

    &lt;p&gt;/etc/my.cnf or /etc/mysql/my.cnf file&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi	/etc/mysql/my.cnf
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mysql&quot;&gt;Mysql服务&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;开机启动Mysql服务设置，进入mysql目录执行下面命令：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cp mysql.server /etc/init.d/mysql
 chmod +x /etc/init.d/mysql
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加mysql用户
 chkconfig –add mysql&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql.server 选项设置，在 /etc/my.cnf file&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mysqld]

 datadir=/usr/local/mysql/var

 socket=/var/tmp/mysql.sock

 port=3306

 user=mysql

 [mysql.server]

 basedir=/usr/local/mysql
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql.server 选项&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Format&lt;/td&gt;
          &lt;td&gt;Description&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–basedir&lt;/td&gt;
          &lt;td&gt;Path to MySQL installation directory&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–datadir&lt;/td&gt;
          &lt;td&gt;Path to MySQL data directory&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–pid-file&lt;/td&gt;
          &lt;td&gt;File in which server should write its process ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;–service-startup-timeout&lt;/td&gt;
          &lt;td&gt;How long to wait for server startup&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;unixlinux-&quot;&gt;在 Unix/Linux 使用通用的二进制文件安装&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 mysql&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; groupadd mysql
 useradd -r -g mysql -s /bin/false mysql
 cd /usr/local/apps/
 tar zxvf /path/to/mysql-VERSION-OS.tar.gz
 ln -s full-path-to-mysql-VERSION-OS mysql
 cd mysql
 chown -R mysql .
 chgrp -R mysql .
 scripts/mysql_install_db --user=mysql
 chown -R root .
 chown -R mysql data
 bin/mysqld_safe --user=mysql &amp;amp;
 # Next command is optional
 cp support-files/mysql.server /etc/init.d/mysql.server
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;环境变量配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;末尾追加&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;MYSQL_HOME = /usr/local/apps/mysql
export PATH=$PATH:$MYSQL_HOME/bin
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;section-4&quot;&gt;其他&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;设置编码格式&lt;/p&gt;

    &lt;p&gt;找到mysql启动配置文件，如my.cnf&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi my.cnf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;追加以下内容&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mysqld]   
 character_set_server = utf8

 [mysql]
 default-character-set = utf8
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;进入mysql，查看字符编码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SHOW VARIABLES LIKE 'character%'
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;其他常用参数&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mysqld]   
 basedir      = path          # 使用给定目录作为根目录(安装目录)。
 datadir      = path          # 从给定目录读取数据库文件。
 pid-file     = filename      # 为mysqld程序指定一个存放进程ID的文件(仅适用于UNIX/Linux系统);


 socket = /tmp/mysql.sock     # 为MySQL客户程序与服务器之间的本地通信指定一个套接字文件(Linux下默认是/var/lib/mysql/mysql.sock文件)
 port             = 3306      # 指定MsSQL侦听的端口
 key_buffer       = 384M      # key_buffer是用于索引块的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)。
                                索引块是缓冲的并且被所有的线程共享，key_buffer的大小视内存大小而定。
 table_cache      = 512       # 为所有线程打开表的数量。增加该值能增加mysqld要求的文件描述符的数量。可以避免频繁的打开数据表产生的开销
 sort_buffer_size = 2M        # 每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。
                                注意：该参数对应的分配内存是每连接独占！如果有100个连接，那么实际分配的总共排序缓冲区大小为100×6=600MB
 read_buffer_size = 2M        # 读查询操作所能使用的缓冲区大小。和sort_buffer_size一样，该参数对应的分配内存也是每连接独享。
 query_cache_size = 32M       # 指定MySQL查询结果缓冲区的大小
 read_rnd_buffer_size    = 8M # 改参数在使用行指针排序之后，随机读用的。
 myisam_sort_buffer_size =64M # MyISAM表发生变化时重新排序所需的缓冲
 thread_concurrency      = 8 # 最大并发线程数，取值为服务器逻辑CPU数量×2，如果CPU支持H.T超线程，再×2
 thread_cache            = 8 # #缓存可重用的线程数
 skip-locking                 # 避免MySQL的外部锁定，减少出错几率增强稳定性。
 [mysqldump]
 max_allowed_packet      =16M # 服务器和客户端之间最大能发送的可能信息包

 [myisamchk]
 key_buffer   = 256M
 sort_buffer = 256M
 read_buffer = 2M
 write_buffer = 2M
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备份，还原&lt;/p&gt;

    &lt;p&gt;备份&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysqldump --socket=/usr/local/apps/mysql/data/mysql/mysql.sock --single-transaction=TRUE  -u root -p emsc &amp;gt; emsc.sql
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;还原&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql --socket=/usr/local/apps/mysql/data/mysql/mysql.sock  -u root -p emsc &amp;lt; emsc.sql
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>在linux下安装jdk7</title>
        <link>https://sendoh-akira.github.io/2017/08/31/linux%E5%AE%89%E8%A3%85jdk7.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2017/08/31/linux%E5%AE%89%E8%A3%85jdk7.html</guid>
        <pubDate>Thu, 31 Aug 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在linux下进行安装jdk7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;jdk7&quot;&gt;jdk7安装指南&lt;/h1&gt;

&lt;p&gt;参考安装网址&lt;/p&gt;

&lt;p&gt;1.文档地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://docs.oracle.com/javase/7/docs/webnotes/install/linux/linux-jdk.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下载jdk地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.oracle.com/technetwork/java/javase/downloads/index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到对应的Jdk版本包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jdk-7u&amp;lt;version&amp;gt;-linux-i586.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jdk-7u1-linux-i586.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列表为linux平台Jdk7版本&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;文件名&lt;/td&gt;
      &lt;td&gt;结构&lt;/td&gt;
      &lt;td&gt;用户权限&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jdk-7u&lt;version&gt;-linux-x64.tar.gz&lt;/version&gt;&lt;/td&gt;
      &lt;td&gt;64-bit&lt;/td&gt;
      &lt;td&gt;anyone&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jdk-7u&lt;version&gt;-linux-i586.tar.gz&lt;/version&gt;&lt;/td&gt;
      &lt;td&gt;32-bit&lt;/td&gt;
      &lt;td&gt;anyone&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jdk-7u&lt;version&gt;-linux-x64.rpm&lt;/version&gt;&lt;/td&gt;
      &lt;td&gt;64-bit RPM-based Linux&lt;/td&gt;
      &lt;td&gt;root&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jdk-7u&lt;version&gt;-linux-i586.rpm&lt;/version&gt;&lt;/td&gt;
      &lt;td&gt;32-bit RPM-based Linux&lt;/td&gt;
      &lt;td&gt;root&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section&quot;&gt;安装前准备&lt;/h1&gt;

&lt;p&gt;1.检查JDK命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.查询本地 JDK 安装程序情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -qa|grep java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;卸载发现的本地JDK&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rpm e &amp;lt;package_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.创建相关目录
Tip:养成好的习惯&lt;/p&gt;

&lt;p&gt;创建一个目录，用来存放各种软件安装包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /usr/local  
mkdir apps
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;jdk&quot;&gt;安装64位jdk&lt;/h1&gt;

&lt;p&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jdk-7u&amp;lt;version&amp;gt;-linux-x64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.下载文件到本地&lt;/p&gt;

&lt;p&gt;如: jdk下载地址为jdk_tarball_url&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget &amp;lt;jdk_tarball_url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.解压tarball&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar zxvf jdk-7u&amp;lt;version&amp;gt;-linux-x64.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.移动到之前创建的存放软件目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv jdk-7u&amp;lt;version&amp;gt;/ /usr/local/apps/
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;linux64jdkrpm&quot;&gt;Linux平台安装64位JDK基于RPM文件&lt;/h1&gt;

&lt;p&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jdk-7u&amp;lt;version&amp;gt;-linux-x64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.下载文件到本地&lt;/p&gt;

&lt;p&gt;如: jdk下载地址为jdk_rpm_url&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget  &amp;lt;jdk_rpm_url&amp;gt;.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.切换到root用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;su - root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.卸载早期版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -e &amp;lt;package_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -ivh jdk-7u&amp;lt;version&amp;gt;-linux-i586.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.更新&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rpm -Uvh jdk-7u&amp;lt;version&amp;gt;-linux-i586.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;收尾工作&lt;/h1&gt;
&lt;p&gt;1.配置环境变量
编辑配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vim /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在该文件的末尾，添加下面内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JAVA_HOME=/usr/local/apps/jdk-7u&amp;lt;version&amp;gt;
JRE_HOME=$JAVA_HOME/jre
PATH=$PATH:$JAVA_HOME/bin
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JAVA_HOME
export JRE_HOME export PATH export CLASSPATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行命令，刷新该配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.检查安装是否成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -version
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>CDH环境安装</title>
        <link>https://sendoh-akira.github.io/2017/08/31/cdh%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2017/08/31/cdh%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85.html</guid>
        <pubDate>Thu, 31 Aug 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;CDH环境安装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;安装环境&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;centOS 7.1.1503
CDH 5.9.0
mysql 5.6
JDK 1.8
ntp 4.2.6
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;tip: 所有操作均需要管理员(root)权限！&lt;/font&gt;

&lt;h1 id=&quot;section-1&quot;&gt;系统配置文件修改&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;修改系统的sysconfig中的网络配置(master和各个node都需要)&lt;/p&gt;

    &lt;p&gt;查看当前使用网卡,输出内容左上方为使用网卡名称&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ifconfig 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;通常一般为ifcfg-eth0，这里以ifcfg-eth0说明&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi /etc/sysconfig/network-scripts/ifcfg-eth0
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;对照一下内容作修改新增&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; BOOTPROTO=static
 ONBOOT=yes
 IPADDR=192.168.1.200
 GATEWAY=192.168.1.1
 NETMASK=255.255.255.0
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;完成后使网卡信息生效&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; service network restart 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;停用防火墙&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #临时停用
 systemctl stop firewalld.service
 #永久停用
 systemctl disable firewalld.service 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改hosts文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi /etc/hosts
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在文件末尾添加&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 192.168.1.200  master
 192.168.1.201  node1
 192.168.1.202  node2
 192.168.1.203  node3
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置免密码登录&lt;/p&gt;

    &lt;p&gt;master节点：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #回车即可
 ssh-keygen -t  rsa 
 cd .ssh然后执行：
 cat id_rsa.pub &amp;gt;authorized_keys
 chmod 600 authorized_keys
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;slave节点:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #一路回车
 ssh-keygen -t  rsa 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后将authorized_keys从master分发到各子节点(master上)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; scp authorized_keys root@node1:~/.ssh/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;jdk-&quot;&gt;jdk 安装&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;卸载系统自带的JDK(master和各个node都需要)&lt;/p&gt;

    &lt;p&gt;查看系统中原有的jdk&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rpm -qa |grep java  
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;卸载现有jdk,拷贝名称依次卸载&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rpm -e --nodeps javapackages-tools-3.4.1-11.el7.noarch 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将下载好的jdk8的rpm包拷贝到每个节点(master和各个node都需要)&lt;/p&gt;

    &lt;p&gt;按路径安装并显示进度&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rpm -ivh jdk-8u112-linux-x64.rpm
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编辑/etc/profile文件，配置jdk环境变量&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi  /etc/profile
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;配置java环境变量(环境变量配置jdk版本号必须与安装的jdk的版本号一致)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; JAVA_HOME=/usr/java/jdk1.8.0_112
 JRE_HOME=/usr/java/jdk1.8.0_112/jre
 PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib 
 export JAVA_HOME JRE_HOME PATH CLASSPATH
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置完成后执行使其生效&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; source  /etc/profile  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;mysqlmaster&quot;&gt;安装mysql(master上执行)&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;yum的方式安装（不建议）&lt;/p&gt;

    &lt;p&gt;由于centos7中无mysql的仓库地址 因此需要先安装repo源&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;下载完成后执行&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rpm -ivh mysql-community-release-el7-5.noarch.rpm
 yum install mysql-server
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;离线安装&lt;/p&gt;

    &lt;p&gt;用到的rpm文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; MySQL-client-5.6.35-1.el7.x86_64.rpm
 MySQL-server-5.6.35-1.el7.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;先安装server，再安装client&lt;/p&gt;

    &lt;p&gt;mysql安装完毕后执行&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #启动mysql
 mysql  service mysql start
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;设置密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysqladmin -u root password '123456'  
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;进入数据库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;创建cdh环境需要的数据库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #创建hive数据库
 create database hive DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 
 #创建amon数据库
 create database amon DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 
 #创建oozie数据库
 create database oozie DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 
 #创建rman数据库
 create database rman DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 
 #创建rema数据库
 create database rema DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 
 #创建nas数据库
 create database nas DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 
 #创建nms数据库
 create database nms DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 
 #创建Sentry数据库
 create database sentry DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
 #创建hue数据库
 create database hue DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;分别授权：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;刷新权限：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; flush privileges;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;ntpmasternode&quot;&gt;ntp时间同步的安装（master和各个node都需要）&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载ntp的rpm离线安装包，然后复制到各个node上&lt;/p&gt;

    &lt;p&gt;如下载ntp-4.2.6.tar.gz  拷贝到master和各个node上，然后解压，进入
cd ntp-4.2.6&lt;/p&gt;

    &lt;p&gt;然后执行以下步骤&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ./configure --prefix=/usr/local/ntp --enable-all-clocks --enable-parse-clocks
 make
 make install 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;编译完成后在master上&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi /etc/ntp.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; server 127.127.1.0
 fudge 127.127.1.0 stratum 8
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;编译完成后在每个node上&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi /etc/ntp.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; server  master
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;都修改完成后，master和各个node上分别执行：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; systemctl enable ntpd
 systemctl start ntpd
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在各个node上执行&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; ntpdate -u  master
&lt;/code&gt;&lt;/pre&gt;

    &lt;font color=&quot;red&quot;&gt;附：ntp服务要修改成随系统启动！！&lt;/font&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;nfs&quot;&gt;安装nfs支持&lt;/h1&gt;

&lt;p&gt;要随系统启动,都需要安装&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install rpcbind.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service rpcbind start 
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;附：rpcbind 服务要随系统启动&lt;/font&gt;

&lt;h1 id=&quot;section-2&quot;&gt;修改系统参数&lt;/h1&gt;

&lt;p&gt;SELINUX(master和node都需要改)&lt;/p&gt;

&lt;p&gt;修改/etc/selinux/config（重启后永久生效）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/selinux/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELINUX=disabled 	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;swappiness（master和node都需要改）&lt;/p&gt;

&lt;p&gt;修改/etc/sysctl.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi  /etc/sysctl.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改内容,在这个文档的最后加上这样一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm.swappiness=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑开机启动文件&lt;/p&gt;

&lt;p&gt;mysql，ntp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/rc.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service mysqld start
systemctl start ntpd
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;cloudera-manager-server-agent&quot;&gt;安装Cloudera Manager Server 和Agent&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;主节点master解压安装cloudera manager的目录默认位置在/opt下，解压：
tar -zxvf cloudera-manager*.tar.gz将解压后的cm-5.9.0和cloudera目录放到/opt目录下。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为Cloudera Manager 5建立数据库&lt;/p&gt;

    &lt;p&gt;首先需要去MySql的官网下载JDBC驱动，地址：http://dev.mysql.com/downloads/connector/j/&lt;/p&gt;

    &lt;p&gt;找到mysql-connector-java-5.1.35-bin.jar，重命名为mysql-connector.jar放到/opt/cm-5.9.0/share/cmf/lib/中。&lt;/p&gt;

    &lt;p&gt;hive jdbc驱动放置路径：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /opt/cloudera/parcels/CDH-5.9.0-1.cdh5.9.0.p0.23/lib/hive/lib 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;ooize jdbc驱动放置路径：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /var/lib/oozie/lib
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在主节点初始化CM5的数据库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /opt/cm-5.9.0/share/cmf/schema/scm_prepare_database.sh mysql cm -hlocalhost -uroot -p123456 --scm-host localhost scm scm scm（一行）
&lt;/code&gt;&lt;/pre&gt;

    &lt;font color=&quot;red&quot;&gt;注:123456为mysql数据库密码&lt;font&gt; 

&lt;/font&gt;&lt;/font&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Agent配置&lt;/p&gt;

    &lt;p&gt;修改/opt/cm-5.9.0/etc/cloudera-scm-agent/config.ini中的server_host为主节点的主机名。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi /opt/cm-5.9.0/etc/cloudera-scm-agent/config.ini
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;修改内容为&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; server_host=master
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同步Agent到其他节点&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; scp -r /opt/cm-5.9.0 root@node1:/opt/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在所有节点创建cloudera-scm用户&lt;/p&gt;

    &lt;p&gt;useradd –system –home=/opt/cm-5.9.0/run/cloudera-scm-server/ –no-create-home –shell=/bin/false –comment “Cloudera SCM User” cloudera-scm&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;准备Parcels，用以安装CDH5&lt;/p&gt;

    &lt;p&gt;将CHD5相关的Parcel包放到主节点的/opt/cloudera/parcel-repo/目录中（parcel-repo需要手动创建）。&lt;/p&gt;

    &lt;p&gt;相关的文件如下&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; CDH-5.9.0-1.cdh5.9.0.p0.23-el7.parcel
 CDH-5.9.0-1.cdh5.9.0.p0.23-el7.parcel.sha1
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;最后将CDH-5.9.0-1.cdh5.9.0.p0.23-el7.parcel.sha1重命名为CDH-5.9.0-1.cdh5.9.0.p0.23-el7.parcel.sha，这点必须注意，否则，系统会重新下载CDH-5.9.0-1.cdh5.9.0.p0.23-el7.parcel.sha1文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相关启动脚本&lt;/p&gt;

    &lt;p&gt;master&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #启动服务端
 /opt/cm-5.9.0/etc/init.d/cloudera-scm-server start
 #启动Agent服务
 /opt/cm-5.9.0/etc/init.d/cloudera-scm-agent start
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;slave&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #启动Agent服务
 /opt/cm-5.9.0/etc/init.d/cloudera-scm-agent start
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;我们启动的其实是个service脚本，需要停止服务将以上的start参数改为stop就可以了，重启是restart。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CDH5的安装配置&lt;/p&gt;

    &lt;p&gt;Cloudera Manager Server和Agent都启动以后，就可以进行CDH5的安装配置了。这时可以通过浏览器访问主节点的7180端口(地址为：http://masterIP:7180)测试一下了（由于CM Server的启动需要花点时间，这里可能要等待一会才能访问），默认的用户名和密码均为admin&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;kerberos&quot;&gt;kerberos配置&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;环境

192.168.1.203 node3(kdc主机)
192.168.1.200 master(kdc从节点)
192.168.1.202 node2(kdc从节点)
192.168.1.201 node1(kdc从节点)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;kerberos的安装和配置&lt;/p&gt;

    &lt;font color=&quot;red&quot;&gt;注：kdc主机需要安装krb5-lib-1.13.2,krb5-server-1.13.2,krb5-workstation-1.13.2
kdc的分节点上只需安装krb5-lib-1.1.3.2,krb5-workstation-1.13.2&lt;/font&gt;

    &lt;p&gt;检查系统中是否已经自带了krb&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rpm -qa|grep krb5
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;如果有则先卸载：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rpm -e --nodeps +文件名(包括krb5-lib,krb5-workstation)
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;kdc主机上安装&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rpm -ivh krb5-lib-1.13.2.rpm
 rpm -ivh krb5-workstation-1.13.2.rpm
 rpm -ivh krb5-server-1.13.2.rpm
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;kdc分节点安装&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rpm -ivh krb5-lib-1.13.2.rpm
 rpm -ivh krb5-workstation-1.13.2.rpm
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改配置文件&lt;/p&gt;

    &lt;p&gt;只有kdc主机上修改&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi  /var/kerberos/krb5kdc/kdc.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;修改内容&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [kdcdefaults]
 kdc_ports = 88 
 kdc_tcp_ports = 88 
	
 [realms]
 HADOOP.COM = {
 #master_key_type = aes256-cts
 acl_file = /var/kerberos/krb5kdc/kadm5.acl	
 dict_file = /usr/share/dict/words
 admin_keytab = /var/kerberos/krb5kdc/kadm5.keytab
 max_renewable_life = 7d 
 support_enctypes = aes128-cts:normal des3_hmac_sha1:normal arcfour-hmac:normal des-hmac:normal	
 }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;说明：
 HADOOP.COM:是设定的realms。名字随意。大小写敏感，一般为了识别使用全部大写。
 supported_enctypes:支持的校验方式。注意把aes256-cts去掉。&lt;/p&gt;

    &lt;p&gt;修改Kerberos的配置信息(kdc主机和节点上都要修改)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; vi  /etc/krb5.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;krb5.conf修改内容&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [logging]
 default = FILE:/var/log/krb5libs.log
 kdc = FILE:/var/log/krb5kdc.log
 amdin_server = FILE:/var/log/kadmind.log
	
	
 [libdefaults]
 default_realm = DAYOU.COM
 dns_lookup_kdc = false
 dns_lookup_realm = false
 ticket_lifetime = 86400
 renew_lifetime = 604800
 forwardable = true
 default_tgs_enctypes = rc4-hmac
 default_tkt_enctypes = rc4-hmac
 permitted_enctypes = rc4-hmac
 udp_preference_limit = 1
 kdc_timeout = 3000
	
 [realms]
 DAYOU.COM = {
 kdc = node3
 admin_server = node3
 }
	
 [domain_realm]
 .hadoop.com = HADOOP.COM
 hadoop.com = HADOOP.COM
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;以下kerberos database步骤只在kdc主机上操作：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建/初始化kerberos database&lt;/p&gt;

    &lt;p&gt;初始化并启动：完成上面两个配置文件后，就可以进行初始化并启动了。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /usr/sbin/kdb5_util create -s -r DAYOU.COM
&lt;/code&gt;&lt;/pre&gt;

    &lt;font color=&quot;red&quot;&gt;可能遇到的问题：
 如果需要重建数据库,以下两步：&lt;/font&gt;

    &lt;pre&gt;&lt;code&gt; kdb5_util -r DAYOU.COM -m destroy -f
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;将目录/var/kerberos/krb5kdc下的principal相关的文件删除即可&lt;/p&gt;

    &lt;p&gt;当Kerberos database创建好后，可以看到目录 /var/kerberos/krb5kdc 下生成了几个文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; kadms.acl
 kdc.cnf
 principal
 principal.kadms
 principal.kadms.lock
 principal.ok
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加database administrator&lt;/p&gt;

    &lt;p&gt;我们需要为Kerberos database添加administrative principals (即能够管理database的principals)&lt;/p&gt;

    &lt;p&gt;在maste KDC上执行：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /usr/sbin/kadmin.local -q &quot;addprinc admin/admin&quot;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;并为其设置密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; kadmin.local
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为database administrator设置ACL权限&lt;/p&gt;

    &lt;p&gt;在KDC上我们需要编辑acl文件来设置权限，该acl文件的默认路径是 /var/kerberos/krb5kdc/kadm5.acl（也可以在文件kdc.conf中修改）。Kerberos的kadmind daemon会使用该文件来管理对Kerberos database的访问权限。对于那些可能会对pincipal产生影响的操作，acl文件也能控制哪些principal能操作哪些其他pricipals。&lt;/p&gt;

    &lt;p&gt;为administrator设置权限：将文件/var/kerberos/krb5kdc/kadm5.acl的内容编辑为&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; */admin@DAYOU.COM *
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;代表名称匹配*/admin@HADOOP.COM 都认为是admin，权限是 *。代表全部权限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在master KDC启动Kerberos daemons&lt;/p&gt;

    &lt;p&gt;手动启动&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; service krb5kdc start
 service kadmin start
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;设置开机自动启动&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; chkconfig krb5kdc on
 chkconfig kadmin on
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;现在KDC已经在工作了。这两个daemons将会在后台运行，可以查看它们的日志文件（/var/log/krb5kdc.log 和 /var/log/kadmind.log）。&lt;/p&gt;

    &lt;p&gt;kdc主机上验证：&lt;/p&gt;

    &lt;p&gt;创建用户：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; kadmin.local
 #添加用户app1
 addprinc app1
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;用户列表：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; kadmin.local
 listprincs
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后退出exit
 执行kinit app1
 然后执行klist  输出显示信息&lt;/p&gt;

    &lt;p&gt;kdc节点上安装成功验证：
 kinit app1回车输入密码
 klist输出显示信息
 KDC创建用户并生成keytab文件：
 首先输入kadmin.local回车&lt;/p&gt;

    &lt;p&gt;使用addprinc,delprinc,modprinc,listprincs命令。主要命令：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # 进入kadmin
 kadmin.local 
 #（创建用户）
 addprinc app1
	
 #（删除用户）
 delprinc app1
 #（用户列表）
 listprincs
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;生成keytab:使用xst命令或者ktadd命令：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #(xxx代表keytab文件存放路径可以自定义，kerberos.keytab文件名可以自己修改，app1代表创建的用户名)
 kadmin.local
 xst -k /xxx/kerberos.keytab app1
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;可能遇到的问题：
 hue启动时报：kinit: KDC can’t fulfill requested option while renewing credentials&lt;/p&gt;

    &lt;p&gt;解决：
 先执行kinit -R，回车，会报&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; kinit: KDC can't fulfill requested option while renewing credentials
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;kadmin.local回车&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; modprinc -maxrenewlife 1week krbtgt/DAYOU.COM@DAYOU.COM
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;exit退出即可，然后重启hue&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;sentry&quot;&gt;添加sentry服务&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;访问http://192.168.1.200:7180/&lt;/p&gt;

    &lt;p&gt;登录进去后，在Cluster1上点击展开：选择添加服务&lt;/p&gt;

    &lt;p&gt;然后勾选sentry，继续&lt;/p&gt;

    &lt;p&gt;输入数据库名和密码，然后测试连接，成功后即可。
 如果启动报缺少驱动包，在node2节点上（配置sentry服务的节点上）
 /opt/cloudera/parcels/CDH-5.9.0-1.cdh5.9.0.p0.23/lib/sentry/lib放入驱动包即可。&lt;/p&gt;

    &lt;p&gt;添加sentry用户和组
 group&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; hive
 impala
 hue
 solr
 kafka
 hbase
 dybdp
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;connect&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; hive
 impala
 hue
 hdfs
 solr
 kafka
 hbase
 dybdp
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;附加：
 oozie也和mysql交互，需要放驱动jar包，&lt;/p&gt;

    &lt;p&gt;位置：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /var/lib/oozie/mysql-connector.jar
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;redissentinel&quot;&gt;Redis分布式环境搭建以及哨兵sentinel配置&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;环境&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 192.168.1.201 node1(redis主节点)
 192.168.1.202 node2(redis从节点)
 192.168.1.203 node3(redis从节点)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装&lt;/p&gt;

    &lt;p&gt;首先进入redis解压目录 然后执行make，执行完毕后执行make install&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cd /redis-3.6.5/
 make
 make install
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;node1配置&lt;/p&gt;

    &lt;p&gt;redis.conf&lt;/p&gt;

    &lt;p&gt;把下面对应的注释掉&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # bind 127.0.0.1  Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程，设置为no

 daemonize no
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;保护模式 ，修改为no&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; protected-mode no
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;设置密码
 解开requirepass foobar,修改为&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #（123456为设置的密码）
 requirepass 123456 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;sentinel.conf&lt;/p&gt;

    &lt;p&gt;保护模式(先打开注释)，修改为no&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; protected-mode no
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加以下内容&lt;/p&gt;

    &lt;p&gt;先去掉自带的 sentinel monitor mymaster 127.0.0.1 6379&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #sentinel monitor mymaster 127.0.0.1 6379
 sentinel monitor mymaster 192.168.1.201 6379 2
 sentinel down-after-milliseconds mymaster 30000
 sentinel parallel-syncs mymaster 1
 sentinel failover-timeout mymaster 180000
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;node2、node3配置完全一样：&lt;/p&gt;

    &lt;p&gt;redis.conf&lt;/p&gt;

    &lt;p&gt;把下面对应的注释掉
     #bind 127.0.0.1&lt;/p&gt;

    &lt;p&gt;Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程，设置为no&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; daemonize no
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;保护模式，修改为no&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; protected-mode no
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加密码&lt;/p&gt;

    &lt;p&gt;解开requirepass foobar,修改为&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #（123456为设置的密码） 
 requirepass 123456
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;和主机的主从关系配置，添加&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; slaveof 192.168.1.201 6379
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加主机的密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; masterauth 123456
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;sentinel.conf&lt;/p&gt;

    &lt;p&gt;保护模式(先打开注释)，修改为no&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; protected-mode no
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加以下内容
 先去掉自带的sentinel monitor mymaster 127.0.0.1 6379 2&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sentinel monitor mymaster 127.0.0.1 6379 2
 sentinel monitor mymaster 192.168.1.201 6379 2
 sentinel down-after-milliseconds mymaster 30000
 sentinel parallel-syncs mymaster 1
 sentinel failover-timeout mymaster 180000
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;启动方式：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cd /redis-3.6.5/
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;启动node1上的redis：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; redis-server ./redis.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;启动node1上的sentinel：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; redis-sentinel ./sentinel.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;启动node2，node3上的redis：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; redis-server ./redis.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;启动node2，node3上的sentinel：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; redis-sentinel ./sentinel.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;查看验证：&lt;/p&gt;

    &lt;p&gt;在node1上：输入&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; redis-cli -h 192.168.1.201 info Replication
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;回车打印role:master等其他信息&lt;/p&gt;

    &lt;p&gt;在node2上，输入&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; redis-cli -h 192.168.1.202 info Replication
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;回车打印role:slave等其他信息&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;ha&quot;&gt;HA高可用配置&lt;/h1&gt;

&lt;p&gt;需要配置impala  hive  ooize  hdfs的HA
其中ooize、hdfs 直接可以进入后点击ooize(或hdfs)—操作—启用High Availability
就可以了。&lt;/p&gt;

&lt;h1 id=&quot;solrldap&quot;&gt;solr配置ldap&lt;/h1&gt;

&lt;p&gt;登录进入CDH页面然后 solr–配置：&lt;/p&gt;

&lt;p&gt;左侧筛选器：solr（服务范围）—安全性：&lt;/p&gt;

&lt;p&gt;a、启用 LDAP 身份验证：勾选上&lt;/p&gt;

&lt;p&gt;b、Solr 安全身份验证：勾选kerberos&lt;/p&gt;

&lt;p&gt;c、LDAP URL 填写：ldap://node3:389&lt;/p&gt;

&lt;p&gt;d、LDAP BaseDN 填写：ou=People,dc=dayou,dc=com&lt;/p&gt;

&lt;p&gt;保存&lt;/p&gt;

&lt;p&gt;然后用浏览器访问http://192.168.1.201:8983/solr，弹框输入用户名和密码即可。&lt;/p&gt;

&lt;p&gt;此用户是ldap上创建过的用户&lt;/p&gt;

&lt;h1 id=&quot;linux&quot;&gt;Linux修改系统时区及时间&lt;/h1&gt;

&lt;p&gt;用root用户登录&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;修改时区（将Asia/shanghai-上海时区写入当前时区）&lt;/p&gt;

    &lt;p&gt;提示是否覆盖,输入Y回车,&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; cp -f /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; date
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;查看时区和时间（CST,中国时区）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改时间&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; date -s &quot;2012-11-03 10:25:25&quot;
 #写入CMOS
 clock -w  

 如果service层所处时间和集群所在服务器时间不一致会导致service调用失败！！
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;kafka&quot;&gt;添加kafka服务&lt;/h1&gt;

&lt;p&gt;安装包准备：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KAFKA-2.0.2-1.2.0.2.p0.5-el7.parcel
KAFKA-2.0.2-1.2.0.2.p0.5-el7.parcel.sha1
KAFKA-1.2.0.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下步骤都在master上执行：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;相关文件准备&lt;/p&gt;

    &lt;p&gt;把KAFKA-2.0.2-1.2.0.2.p0.5-el7.parcel，KAFKA-2.0.2-1.2.0.2.p0.5-el7.parcel.sha1这两个文件都放在/opt/cloudera/parcel-repo下，&lt;/p&gt;

    &lt;p&gt;然后重命名&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mv KAFKA-2.0.2-1.2.0.2.p0.5-el7.parcel.sha1 KAFKA-2.0.2-1.2.0.2.p0.5-el7.parcel.sha
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;把KAFKA-1.2.0.jar放在/opt/cloudera/csd下&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动cm服务，检查更新parcel，分配并激活percel包&lt;/p&gt;

    &lt;p&gt;访问http://192.168.1.200:7180登录进去后：
 点击“主机”–“Parcel”进入后选择“检查新Parcel”，然后它会自动找到kafka，点击操作中的分配，执行完成后，点击激活就行了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在CDH中添加kafka服务&lt;/p&gt;

    &lt;p&gt;在CDH中添加kafka服务，修改以下配置：&lt;/p&gt;

    &lt;p&gt;填写Source Brokers List&lt;/p&gt;

    &lt;p&gt;填写Kafka Broker所在节点构成的列表（用逗号分隔），如下(实际根据节点分配)：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; node1:9092,node2:9092,node3:9092
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;填写Destination Brokers List(实际根据节点分配)
 若添加了Kafka MirrorMaker，则可填写其所在节点构成的列表；若未添加Kafka MirrorMaker，可填写任意服务器即可，如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; node3:9092
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改Java Heap Size&lt;/p&gt;

    &lt;p&gt;填写上面列表后，点击继续，出错后，Kafka服务未启动。返回集群配置，打卡Kafka服务配置页，查找“Java Heap Size of Broker”项，将对大小从50MB修改为256MB。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置Topic Whitelist&lt;/p&gt;

    &lt;p&gt;配置Topic Whitelist项为正则表达式：(?!x)x  保存更改&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kafka超级用户配置&lt;/p&gt;

    &lt;p&gt;super users&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; kafka
 dybdp
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
      </item>
    
      <item>
        <title>Install Nginx On CentOS With SSL, PCRE, GeoIP, Zlib, Gzip And DAV Support</title>
        <link>https://sendoh-akira.github.io/2016/09/23/install-nginx-on-centos-with-ssl-pcre-geoip-zlib-gzip-and-dav-support.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/09/23/install-nginx-on-centos-with-ssl-pcre-geoip-zlib-gzip-and-dav-support.html</guid>
        <pubDate>Fri, 23 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Nginx(pronounced “engine x”) is a free, open-source, high-performance HTTP server. Nginx is known for its stability, rich feature set, simple configuration, and low resource consumption. This tutorial shows how you can compile and install Nginx on CentOS server with SSL, PCRE, GeoIP, Zlib, Gzip and DAV supp&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;add-a-repo-for-some-packages-that-we-need&quot;&gt;Add a repo for some packages that we need:&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://support.rackspace.com/how-to/install-epel-and-additional-repositories-on-centos-and-red-hat&quot;&gt;Install EPEL, IUS, and Remi repositories on CentOS and Red Hat&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;EPEL(Extra Packages for Enterprise Linux) Repo是Linux发行版中最大的软件仓库之一，免费，丰富的软件包更新。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-rpm-macros-6-11.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;pre-installation&quot;&gt;Pre-Installation&lt;/h1&gt;

&lt;p&gt;First we install httpd-devel, pcre, pcre-devel, zlib, zlib-devel, perl, geoip and geoip-devel gcc gcc-c++ packages like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# yum install -y httpd-devel pcre perl pcre-devel zlib zlib-devel GeoIP GeoIP-devel  gcc gcc-c++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create group and user for nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# /usr/sbin/groupadd -f nginx
# /usr/sbin/useradd -g nginx nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;download-required-packages&quot;&gt;Download required packages&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# cd /usr/local/src/
# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz
# wget http://zlib.net/zlib-1.2.8.tar.gz
# wget https://www.openssl.org/source/openssl-1.0.1u.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;now-you-have-to-untar-these-files&quot;&gt;Now you have to untar these files.&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# tar -xvf pcre-8.38
# tar -xvf zlib-1.2.8.tar.gz
# tar -xvf openssl-1.0.1u.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;download-nginx-source-package&quot;&gt;Download Nginx source package&lt;/h1&gt;

&lt;p&gt;You need to download Nginx source package from &lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;,nginx wiki from &lt;a href=&quot;https://www.nginx.com/resources/wiki&quot;&gt;nginx wiki&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd /usr/local/src/
# wget  http://nginx.org/download/nginx-1.11.4.tar.gz
# tar -xvf nginx-1.11.4.tar.gz
# cd nginx-1.11.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;compile-and-install-nginx&quot;&gt;Compile and Install Nginx&lt;/h1&gt;

&lt;p&gt;Now you can compile and install Nginx with the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ./configure \
    --user=nginx  \
    --group=nginx  \
    --prefix=/usr/local/develop/nginx  \
    --sbin-path=/usr/local/develop/nginx/bin/nginx  \
    --conf-path=/usr/local/develop/nginx/etc/nginx.conf  \
    --error-log-path=/usr/local/develop/nginx/log/error.log  \
    --http-log-path=/usr/local/develop/nginx/log/access.log  \
    --http-client-body-temp-path=/var/lib/nginx/tmp/client_body  \
    --http-proxy-temp-path=/var/lib/nginx/tmp/proxy  \
    --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi  \
    --pid-path=/usr/local/develop/nginx/pid/nginx.pid  \
    --lock-path=/var/lock/subsys/nginx  \
    --with-http_ssl_module  \
    --with-http_realip_module  \
    --with-http_addition_module  \
    --with-http_sub_module  \
    --with-http_dav_module \
    --with-http_flv_module \
    --with-http_gzip_static_module \
    --with-http_stub_status_module \
    --with-mail \
    --with-mail_ssl_module \
    --with-openssl=../openssl-1.0.1u \
    --with-pcre \
    --with-pcre=../pcre-8.38 \
    --with-zlib=../zlib-1.2.8 \
    --with-http_geoip_module \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find out more options by using the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```
# ./configure --help
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```
# make
# make install
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configuration Summary&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx path prefix: &quot;/usr/local/nginx&quot;
nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;
nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;
nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;
nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;
nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;
nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;
nginx http client request body temporary files: &quot;client_body_temp&quot;
nginx http proxy temporary files: &quot;proxy_temp&quot;
nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;start-nginx-server&quot;&gt;Start Nginx Server&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# /usr/local/develop/nginx/bin/nginx -c /usr/local/develop/nginx/etc/nginx.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;stop-nginx-server&quot;&gt;Stop Nginx Server&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# /usr/local/develop/nginx/bin/nginx -s stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;testing&quot;&gt;Testing&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# /usr/local/develop/nginx/bin/nginx -V
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;brower&quot;&gt;brower&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;http://ip/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://www.howtoforge.com/install-nginx-on-centos-5.5-with-ssl-pcre-geoip-zlib-gzip-and-dav-support&quot;&gt;reference by the blog&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Spring Interview Questions and Answers</title>
        <link>https://sendoh-akira.github.io/2016/09/22/spring_interview_questions_and_answers.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/09/22/spring_interview_questions_and_answers.html</guid>
        <pubDate>Thu, 22 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Spring面试题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;spring-core&quot;&gt;Spring Core&lt;/h1&gt;

&lt;p&gt;1.什么是Spring？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.Spring有哪些优点？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。

控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。

面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。

容器：Spring包含并管理应用程序对象的配置及生命周期。

MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。

事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。

异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.Spring框架有哪些模块？&lt;/p&gt;

&lt;p&gt;Spring框架的基本模块如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Core module
Bean module
Context module
Expression Language module
JDBC module
ORM module
OXM module
Java Messaging Service(JMS) module
Transaction module
Web module
Web-Servlet module
Web-Struts module
Web-Portlet module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.解释核心容器(应用上下文)模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.BeanFactory – BeanFactory 实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。
最常用的BeanFactory实现是XmlBeanFactory类。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.XmlBeanFactory&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.解释AOP模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.解释抽象JDBC和DAO模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.解释对象/关系映射集成模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.解释web模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11.解释Spring MVC模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;12.Spring的配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring的配置文件是一个XML文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;13.Spring IoC容器是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;14.IOC有什么优点？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15.应用上下文是如何实现的？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FileSystemXmlApplicationContext 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。
FileSystemXmlApplicationContext 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。
WebXmlApplicationContext：该容器加载xml文件，这些文件定义了web应用中所有的beans。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;16.Bean Factory和ApplicationContext有什么区别？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ApplicationContext提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。另外，容器或者容器中beans的操作，这些必须以bean工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了MessageSource，该接口用于获取本地消息，实际的实现是可选的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;17.Spring应用程序看起来像什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一个定义功能的接口

实现包括属性，setter和getter方法，功能等

Spring AOP

Spring的XML配置文件

使用该功能的客户端编程

依赖注入
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;18.Spring中的依赖注入是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。

依赖注入和控制反转

Dependency Injection 和 Inversion of Control 其实就是一个东西的两种不同的说法而已。本质上是一回事。Dependency Injection 是一个程序设计模式和架构模型， 一些时候也称作 Inversion of Control，尽管在技术上来讲，Dependency Injection 是一个 Inversion of Control 的特殊实现，Dependency Injection 是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个数据库连接以参数的形式传到一个对象的结构方法里面而不是在那个对象内部自行创建一个连接。Inversion of Control 和 Dependency Injection 的基本思想就是把类的依赖从类内部转化到外部以减少依赖。 应用Inversion of Control，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所以，Inversion of Control 是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;19.有哪些不同类型的IOC(依赖注入)？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。

Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;20.你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21.什么是Spring Beans？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。

在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;22.Spring Bean中定义了什么内容？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;23.如何向Spring 容器提供配置元数据？&lt;/p&gt;

&lt;p&gt;有三种方式向Spring 容器提供元数据:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XML配置文件

基于注解配置

基于Java的配置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;24.你如何定义bean的作用域？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候通过’scope’属性定义即可。例如，当Spring需要产生每次一个新的bean实例时，应该声明bean的scope属性为prototype。如果每次你希望Spring返回一个实例，应该声明bean的scope属性为singleton。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;25.说一下Spring中支持的bean作用域&lt;/p&gt;

&lt;p&gt;Spring框架支持如下五种不同的作用域：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;singleton：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。

prototype：一个bean可以定义多个实例。

request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。

session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境.

globalSession：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境.

bean默认的scope属性是’singleton‘。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;26.Spring框架中单例beans是线程安全的吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不是，Spring框架中的单例beans不是线程安全的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;27.解释Spring框架中bean的生命周期&lt;/p&gt;

&lt;p&gt;Spring容器读取XML文件中bean的定义并实例化bean。&lt;/p&gt;

&lt;p&gt;Spring根据bean的定义设置属性值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。

如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。

如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。

如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方。

如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。

如果该bean实现了DisposableBean，调用destroy()方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;28.哪些是最重要的bean生命周期方法？能重写它们吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;有两个重要的bean生命周期方法。第一个是setup方法，该方法在容器加载bean的时候被调用。第二个是teardown方法，该方法在bean从容器中移除的时候调用。

bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;29.什么是Spring的内部bean？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;30.如何在Spring中注入Java集合类？&lt;/p&gt;

&lt;p&gt;Spring提供如下几种类型的集合配置元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list元素用来注入一系列的值，允许有相同的值。

set元素用来注入一些列的值，不允许有相同的值。

map用来注入一组”键-值”对，键、值可以是任何类型的。

props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;31.什么是bean wiring？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;32.什么是bean自动装配？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和&amp;lt; property&amp;gt;元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;33.解释自动装配的各种模式？&lt;/p&gt;

&lt;p&gt;自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。

byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。

byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。

constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。

autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;34.自动装配有哪些局限性？&lt;/p&gt;

&lt;p&gt;自动装配有如下局限性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;重写：你仍然需要使用 和&amp;lt; property&amp;gt;设置指明依赖，这意味着总要重写自动装配。

原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。

模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;35.你可以在Spring中注入null或空字符串吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;完全可以。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;36.什么是Spring基于Java的配置？给出一些注解的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。

以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;37.什么是基于注解的容器配置?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;38.如何开启注解装配？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;39.@Required 注解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;40.@Autowired 注解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;41.@Qualifier 注解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;42.在Spring框架中如何更有效的使用JDBC？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate(例子)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;43.JdbcTemplate&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;44.Spring对DAO的支持&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;45.使用Spring可以通过什么方式访问Hibernate？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用Spring有两种方式访问Hibernate：

使用Hibernate Template的反转控制以及回调方法

继承HibernateDAOSupport，并申请一个AOP拦截器节点
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;46.Spring支持的ORM&lt;/p&gt;

&lt;p&gt;Spring支持以下ORM：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hibernate

iBatis

JPA (Java -Persistence API)

TopLink

JDO (Java Data Objects)

OJB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;47.如何通过HibernateDaoSupport将Spring和Hibernate结合起来？&lt;/p&gt;

&lt;p&gt;使用Spring的SessionFactory 调用LocalSessionFactory。结合过程分为以下三步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;配置Hibernate SessionFactory

继承HibernateDaoSupport实现一个DAO

使用AOP装载事务支持
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;48.Spring支持的事务管理类型&lt;/p&gt;

&lt;p&gt;Spring支持如下两种方式的事务管理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。

声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;49.Spring框架的事务管理有哪些优点？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。

它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).

它支持声明式事务管理。

它可以和Spring 的多种数据访问技术很好的融合。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;50.你更推荐那种类型的事务管理？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;springaop&quot;&gt;Spring面向切面编程(AOP)&lt;/h1&gt;

&lt;p&gt;51.解释AOP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;52.切面(Aspect)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;53.在Spring AOP中concern和 cross-cutting concern的区别是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。

Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;54.连接点(Join point)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;55.通知(Advice)&lt;/p&gt;

&lt;p&gt;通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。&lt;/p&gt;

&lt;p&gt;Spring切面可以执行一下五种类型的通知:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before(前置通知)：在一个方法之前执行的通知。

after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。

after-returning(后置通知)：在某连接点正常完成后执行的通知。

after-throwing(异常通知)：在方法抛出异常退出时执行的通知。

around(环绕通知)：在方法调用前后触发的通知。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;56.切入点(Pointcut)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;57.什么是引入？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;引入允许我们在已有的类上添加新的方法或属性。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;58.什么是目标对象？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;59.什么是代理？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;60.有几种不同类型的自动代理？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BeanNameAutoProxyCreator：bean名称自动代理创建器

DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器

Metadata autoproxying：元数据自动代理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;61.什么是织入？什么是织入应用的不同点？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;62.解释基于XML Schema方式的切面实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在这种情况下，切面由使用XML文件配置的类实现。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;63.解释基于注解方式(基于@AspectJ)的切面实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在这种情况下(基于@AspectJ的实现)，指的是切面的对应的类使用Java 5注解的声明方式。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;spring-web&quot;&gt;Spring Web&lt;/h1&gt;

&lt;p&gt;64.什么是Spring的MVC框架？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;65.DispatcherServlet&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;66.WebApplicationContext&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;67.什么是Spring MVC框架的控制器？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;68.@Controller annotation&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;69.@RequestMapping annotation&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;70.Spring 有多少个模块&lt;/p&gt;

&lt;p&gt;Spring Framework 的功能被组织成了 20 来个模块。这些模块分成&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Core Container,&lt;/li&gt;
  &lt;li&gt;Data Access/Integration,&lt;/li&gt;
  &lt;li&gt;Web,&lt;/li&gt;
  &lt;li&gt;AOP (Aspect Oriented Programming),&lt;/li&gt;
  &lt;li&gt;Instrumentation,&lt;/li&gt;
  &lt;li&gt;Messaging,&lt;/li&gt;
  &lt;li&gt;Test&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;71.使用场景&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Typical full-fledged Spring web application&lt;/li&gt;
  &lt;li&gt;Spring middle-tier using a third-party web framework&lt;/li&gt;
  &lt;li&gt;Remoting usage scenario&lt;/li&gt;
  &lt;li&gt;EJBs - Wrapping existing POJOs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;72.AOP是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aspect-Oriented Programming (面相切面编程 AOP) 用另外的一种编程架构的思考来补充 Object-Oriented Programming (面相对象编程OOP)。OOP 主要的模块单元是 class (类)，而 AOP 是 aspect（切面）。切面使得诸如事务管理等跨越多个类型和对象的关注点模块化。（这样的关注点在 AOP 的字眼里往往被称为 crosscutting （横切关注点））
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>jni使用详解</title>
        <link>https://sendoh-akira.github.io/2016/04/05/jni.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/04/05/jni.html</guid>
        <pubDate>Tue, 05 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;开发中难免要使用jni，现在系统的学习总结一下使用的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;jni&quot;&gt;1 jni概述&lt;/h5&gt;

&lt;p&gt;jni是Java Native Interface的缩写，中文译为“java本地方法接口”。通俗的说，jni是一种技术，通过jni你可以：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java程序中的函数可以调用Native语言写的函数，Native一般是指C/C++编写的代码。&lt;/li&gt;
  &lt;li&gt;Native程序中的函数可以调用Java层的函数，也就是说在C/C++程序中可以调用java的函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jnijni&quot;&gt;2 加载jni库以及注册jni函数&lt;/h5&gt;

&lt;p&gt;加载jni库非常简单，只需要在调用Native函数之前使用&lt;code&gt;System.loadLibrary(&quot;your_libray_name&quot;)&lt;/code&gt;即可。我们的通常做法是在class中的静态块中加载，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.jimbo.jni;

public class JNIInterface {

  static {
    System.loadLibrary(&quot;your_libray_name&quot;);
  }

  //这里可以定义你的Native函数
  public static native final void native_say_hello();

  int a;
  int b;
  public int calc() {
    return a+b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了&lt;code&gt;java&lt;/code&gt;代码编写的方法，那么问题来了，Native代码怎么编写呢？java函数怎么找到对应的Native函数呢？all right,让我们来看一下注册jni的两种方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;借助java的工具程序&lt;code&gt;javah&lt;/code&gt;来实现这一过程。答题流程是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编写java代码，然后编译生成&lt;code&gt;.class&lt;/code&gt;文件。&lt;/li&gt;
  &lt;li&gt;使用javah，例如&lt;code&gt;javah -o output packname.classname&lt;/code&gt;来生成一个叫做&lt;code&gt;output.h&lt;/code&gt;的头文件。&lt;/li&gt;
  &lt;li&gt;在jni层实现这些函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的&lt;code&gt;JNIInterface&lt;/code&gt;类经过上述操作后会得到这样的头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
//...省略
//注：如果java的函数中已经有了“_”，则&quot;_&quot;将会被替换成&quot;_l&quot;
JNIEXPORT void JNICALL Java_com_jimbo_jni_JNIInterface_native_lsay_lhello(JNIEnv *, jclass);

//...省略
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，这个Native函数的名字就是包名+函数名，只是因为“.”在c中有特殊的含义，所以被替换成了”_“。这个过程是这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当java层调用native_say_hello()函数时，他会从对应的JNI库中寻找Java_com_jimbo_jni_JNIInterface_native_lsay_lhello()函数，如果没有就会报错。如果找的到，则会为这个native_say_hello()和Java_com_jimbo_jni_JNIInterface_native_lsay_lhello()建立一个关联关系，其实就是保存jni层函数的函数指针。以后再调用native_say_hello()函数时，直接使用这个函数指针就可以了。当然这个过程是虚拟机来完成的，不需要我们操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;动态注册&lt;/p&gt;

    &lt;p&gt;既然java函数和native函数时一一对应的，那么是不是有一种结构来保存这些数据信息呢？答案是肯定的。在jni技术中，用一个&lt;code&gt;JNINativeMethod&lt;/code&gt;来保存，结构定义如下：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct {
  //java函数名 不用携带包名，待会会有其他方式提供包名，
  //这样查找起来效率就会更高
  const char *name;
  //函数签名信息，包括函数的参数以及函数的返回值等信息
  const char *signature;
  //函数指针，类型为void*
  void* fnptr;
} JNINativeMethod;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，这些对应数据什么时候会被加载出来了呢？其实在调用&lt;code&gt;System.loadLibrary(&quot;your_libray_name&quot;);&lt;/code&gt;之后，紧接着会查看该库中一个叫做&lt;code&gt;JNI_OnLoad()&lt;/code&gt;的函数，如果有就会调用它，动态注册就需要在这里完成。那么究竟如何实现这一个过程呢？需要调用两个函数就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jclass clazz = (*env) -&amp;gt; FindClass(env, className);

(*env) -&amp;gt; RegisterNatives(env, clazz, gMethods, numMethods);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体注册过程可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;string.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;assert.h&amp;gt;

//这个函数是对应java函数的
jstring native_say_hello(JNIEnv *env, jobject thiz) {
  return (*env) -&amp;gt; NewStringUTF(env, &quot;hello, i am from jni~&quot;);
}

//这个函数提供方法的对应信息，通过创建JNINativeMethod结构体来实现
//至于那么参数什么意思 待会具体说
static JNINativeMethod gMethods[] = {
  {&quot;native_say_hello&quot;, &quot;()Ljava/lang/String&quot;, (void)*native_say_hello},
}

//为类的某一个方法注册
static int registerNativeMethod(JNIEnv *env, const char* className, JNINativeMethod *gMethods, int numbers) {
  jclass  clazz = (*env) -&amp;gt; FindClass(env, className);
  if (null == clazz) {
    return JNI_FALSE;
  }
  if ((*env)-&amp;gt;RegisterNatives(env, clazz, gMethods, numMethods) &amp;lt; 0) {  
        return JNI_FALSE;  
  }
  return JNI_TURE;
}

//为所有类的方法注册
static int registerNatives(JNIEnv* env) {  
    const char* kClassName = &quot;com/jimbo/jni/JNIInterface&quot;;//指定要注册的类  
    return registerNativeMethods(env, kClassName, gMethods,  
            sizeof(gMethods) / sizeof(gMethods[0]));
}

//如果成功返回JNI版本, 失败返回-1
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {  
    JNIEnv* env = NULL;  

    if ((*vm)-&amp;gt;GetEnv(vm, (void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {  
        return -1;  
    }  
    assert(env != NULL);  

    if (!registerNatives(env)) {//注册  
        return -1;  
    }  
    //成功  
    return JNI_VERSION_1_4;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的方法我们就可以将jni函数和java的函数注册在一起了。但是上面代码似乎还是有点麻烦的，
其实jni的AndroidRunTime类提供了一个&lt;code&gt;registerNativeMethods()&lt;/code&gt;方法，可以更加简单的实现这
一过程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;string.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;assert.h&amp;gt;

jstring native_say_hello(JNIEnv *env, jobject thiz) {
  return (*env) -&amp;gt; NewStringUTF(env, &quot;hello, i am from jni~&quot;);
}

static JNINativeMethod gMethods[] = {
  {&quot;native_say_hello&quot;, &quot;()Ljava/lang/String;&quot;, (void)*native_say_hello},
}
//以上代码和前面是一样的

//如果成功返回JNI版本, 失败返回-1
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {  
    JNIEnv* env = NULL;   

    if ((*vm)-&amp;gt;GetEnv(vm, (void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {  
        return -1;  
    }  
    assert(env != NULL);  

    if (AndroidRunTime::registerNativeMethods(env, &quot;com/jimbo/jni/JNIInterface&quot;, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) &amp;lt; 0) {//注册  
        return -1;  
    }  
    //成功  
    return JNI_VERSION_1_4;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码比较好理解，但是JNINativeMethod中的signature可能会存在疑问。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&quot;()V&quot;
&quot;()I&quot;
&quot;(II)Ljava/lang/String&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上这些是与函数参数以及返回值一一对对应的。&lt;code&gt;()&lt;/code&gt;里面表示参数，&lt;code&gt;()&lt;/code&gt;外表示的函数的返回值。
比如&lt;code&gt;(II)Ljava/lang/String&lt;/code&gt;就对应这个函数&lt;code&gt;jstring functionName(int ,int)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;具体的对应关系如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;java类型&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;c类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;void&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;void&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jboolean&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;I&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jint&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jlong&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jdouble&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jfloat&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbyte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshort&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[I&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jintarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshortarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbytearray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jchararray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[S&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshortarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jdoublearray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[j&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jlongarray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[z&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbooleanarray&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上是关于基本类型和基本类型的数组，那么类是如何表示的呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果Java函数的参数是class，则以”L”开头，以”;”结尾中间是用”/” 隔开的包及类名。而其对应的C函数名的参数则为jobject. 一个例外是String类，其对应的类为jstring
Ljava/lang/String; String jstring
Ljava/net/Socket; Socket jobject&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;jnienv&quot;&gt;3 JNIEnv介绍&lt;/h5&gt;

&lt;p&gt;JNIEnv，即JNIEnvironment，字面意思就是jni环境。其实他就是一个与线程相关的jni环境结构体。
JNIEnv提供了一些jni系统函数，通过这些函数我们可以做：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用java函数&lt;/li&gt;
  &lt;li&gt;操作jobject对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jnienvjobject&quot;&gt;4 通过JNIEnv操作jobject&lt;/h5&gt;

&lt;p&gt;我们都知道，类都是由方法和成员变量组成的，在jni的规则中，使用jfirldID和jMethod来表示java的
成员变量和方法，可通过jni下面的两个函数得到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jfieldId GetFieldID(jclass clazz, const char *name, const char *sig);
jMethod GetMethodID(jclass clazz, const char *name, const char *sig);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;jclass代表的java中的类，对应&lt;code&gt;java.lang.Class&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;第二个参数就是类的名称&lt;/li&gt;
  &lt;li&gt;第三个参数是函数签名，和前面介绍的一样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;得到jfieldId和jMethod后依然无法调用java函数。那到底该怎么做呢？
不着急，我们看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;jint native_calc(JNIEnv *env, jobject thiz) {

  jclass clazz = env -&amp;gt; FindClass(&quot;com/jimbo/jni/JNIInterface&quot;);
  jmethodID java_calc_id = env -&amp;gt; GetMethodID(clazz, &quot;native_calc&quot;, &quot;()I&quot;);
  jfieldId a_id = env -&amp;gt; GetFieldID(clazz, &quot;a&quot;, &quot;I&quot;);
  jfieldId b_id = env -&amp;gt; GetFieldID(clazz, &quot;b&quot;, &quot;I&quot;);
  jint a = env -&amp;gt; GetIntField(clazz, thiz, a_id);
  jint b = env -&amp;gt; GetIntField(clazz, thiz, b_id);
  return env -&amp;gt; CallIntMethod(env, thiz, java_calc_id, a, b);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这段代码我们知道jni是通过&lt;code&gt;CallIntMethod()&lt;/code&gt;函数来调用了java的函数。&lt;/p&gt;

&lt;p&gt;实际上，jni有一系列类似的函数，形式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;//调用函数
//最后参数是调用函数的参数
NativeType Call&amp;lt;Type&amp;gt;Method(JNIEnv *env, jobject thiz, jmethodID methodID, ...);

//获取成员变量的值
NativeType Get&amp;lt;Type&amp;gt;Field(JNIEnv *env, jobject thiz, jfieldId fieldID);
//或者是
void Set&amp;lt;Typr&amp;gt;FieldID(JNIEnv *env, jobject thiz, jfieldId fieldID, NativeType value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用的还用如下函数:&lt;/p&gt;

&lt;p&gt;GetObjectField(),GetIntField(),GetShortField(),GetCharField()等等。&lt;/p&gt;

&lt;h5 id=&quot;jni-1&quot;&gt;5 jni的垃圾回收以及异常处理&lt;/h5&gt;

&lt;p&gt;在jni中，有三种类型的引用，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Local Reference：包括函数调用是传入的参数，在函数内创建的jobject。Local Reference
最大的特点就是，一旦jni函数结束，就会被回收。&lt;/li&gt;
  &lt;li&gt;Global Reference：全局引用，这种对象不主动释放永远都不会被回收。&lt;/li&gt;
  &lt;li&gt;Weak Reference：弱全局引用，在运行过程中可能被回收。所以在使用前要调用IsSameObject()
来判断他是否已经被回收了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在使用完变量后也可以通过&lt;code&gt;env -&amp;gt; Delete&amp;lt;ReferenceType&amp;gt;Ref&lt;/code&gt;来主动释放内存。例如DeleteLocalRef();&lt;/p&gt;

&lt;p&gt;在jni中，提供了三个函数来截获和处理异常：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ExceptionOccured(),用来判断时候发生了异常。&lt;/li&gt;
  &lt;li&gt;ExceptionClear(),用来清理jni层发生的异常。&lt;/li&gt;
  &lt;li&gt;ThrowNew(),用来向java层抛出异常。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文参考了&lt;a href=&quot;https://book.douban.com/subject/6802440/&quot;&gt;邓凡平的深入理解Android 卷1&lt;/a&gt;以及&lt;a href=&quot;http://blog.csdn.net/chenfeng0104/article/details/7088600&quot;&gt;chenfeng0104的专栏-动态注册JNI&lt;/a&gt;。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>二叉树的分层遍历</title>
        <link>https://sendoh-akira.github.io/2016/03/14/suanfa-erchashufencengbianli.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2016/03/14/suanfa-erchashufencengbianli.html</guid>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;二叉树的分层遍历&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;题目要求：给定一个二叉树的root结点，然后按照每层从左到右的顺序将二叉树结点的值储存在一个二维数组中，每一层一个数组，每一个数组的元素是按照从左到右的顺序进行存储的。&lt;/p&gt;

&lt;p&gt;思路：二叉树的分层打印类似于图的广度优先遍历算法，我们可以借助一个队列实现这个过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化队列 将root结点加入到队列之中&lt;/li&gt;
  &lt;li&gt;判断当前队列是否为空
    &lt;ul&gt;
      &lt;li&gt;不为空，则出队队列的首元素 并且将不为空的结点入队列&lt;/li&gt;
      &lt;li&gt;为空则表示遍历完成&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过上述操作之后就可以得到二叉树分层遍历的顺序了。但是我们并不能得到每一个层都有什么元素这样的信息，我们还需要在遍历的过程中使用变量记录这一个过程。&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;last&lt;/code&gt;变量记录当前打印行的最右结点&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;nLast&lt;/code&gt;变量记录加入队列的最近一个元素&lt;/p&gt;

&lt;p&gt;在元素弹出的时候判断一下是否和&lt;code&gt;last&lt;/code&gt;元素相等，相等则表示要换行了，这时候要更新&lt;code&gt;last&lt;/code&gt;的值，就是将&lt;code&gt;nLast&lt;/code&gt;赋值给&lt;code&gt;last&lt;/code&gt;即可，这样就实现了这个功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
import java.util.*;

public class Java {

	public static void main(String[] args) {
		TreeNode one = new TreeNode(1);
		TreeNode two = new TreeNode(2);
		TreeNode three =new TreeNode(3);
		TreeNode four = new TreeNode(4);
		TreeNode five = new TreeNode(5);
		TreeNode six = new TreeNode(6);
		TreeNode seven = new TreeNode(7);
		TreeNode eight = new TreeNode(8);
		TreeNode nine = new TreeNode(9);
		TreeNode ten = new TreeNode(10);
		TreeNode n11 = new TreeNode(11);
		TreeNode n12 = new TreeNode(12);
		TreeNode n13 = new TreeNode(13);
		TreeNode n14 = new TreeNode(14);

		one.left = two;
		one.right = three;
		//two.left = four;
		two.right = five;
		three.left = six;
		three.right = seven;
		four.left = eight;
		//four.right = nine;
		//five.left = ten;
		five.right = n11;
		six.left = n12;
		six.right = n13;

		n13.right = n14;

		TreePrinter p = new TreePrinter();
		int[][] result = p.printTree(one);
		for (int i = 0; i &amp;lt; result.length; i++) {
			for (int j = 0; j &amp;lt; result[i].length; j++) {
				System.out.print(result[i][j]);
			}
			System.out.println(&quot;&quot;);
		}
	}

}

class TreePrinter {
    public int[][] printTree(TreeNode root) {
        // write code here
    	if (null == root) {
    		return null;
    	}

    	if (null == root.left &amp;amp;&amp;amp; null == root.right) {
    		int[][] result = ;
    		return result;
    	}

    	int[][] result = new int[10][];

    	Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;();	
    	TreeNode last = root;
    	TreeNode nLast = root.right == null ? root.left : root.right;

    	int i = 0;
    	int j = 0;

    	int numOfLine[] = new int[10];

    	result[i] = new int[1];

    	queue.add(root);

    	while(!queue.isEmpty()) {

    		TreeNode tree = queue.poll();
    		result[i][j++] = tree.val;
    		numOfLine[i]++;

    		if (tree.left != null) {
    			queue.add(tree.left);
    			nLast = tree.left;
    		}
    		if (tree.right != null) {
    			queue.add(tree.right);
    			nLast = tree.right;
    		}

    		if (last == tree) {
    			j = 0;
    			i++;
    			result[i] = new int[(int)(Math.pow((double)2, (double)i))];
    			last = nLast;
    		}

    		
    	}

    	int[][] r = new int[i][];
    	//System.out.println(i+&quot;&quot;);
    	for (int g = 0; g &amp;lt; i; g++) {
    		r[g] = new int[numOfLine[g]];
    		for (int h = 0; h &amp;lt; numOfLine[g]; h++) {
    			r[g][h] = result[g][h];
    		}
    	}
    	result = null;
    	return r;
    }
}

class TreeNode {
    public int val = 0;
    public TreeNode left = null;
    public TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}


&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>upsdnu使用说明</title>
        <link>https://sendoh-akira.github.io/2015/12/02/life-upsdnudescription.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/12/02/life-upsdnudescription.html</guid>
        <pubDate>Wed, 02 Dec 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;upsdnu使用说明
任何意见以及建议都可以反馈 在博客下面留言即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;BUG集合：
2016年3月15日20:58:09&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;由于采用thread去请求认证 可能会导致内存泄露问题&lt;/li&gt;
    &lt;li&gt;
      &lt;h2 id=&quot;section&quot;&gt;计算绩点操作数据的时候可能导致了精度丢失&lt;/h2&gt;
      &lt;p&gt;1.alpha_2.1 2016年1月6日16:46:29：(尚未处理)
java.lang.StringIndexOutOfBoundsException: length=0; regionStart=1; regionLength=-2
at java.lang.String.startEndAndLength(String.java:504)
at java.lang.String.substring(String.java:1333)
at com.jimbo.myapplication.MainActivity.getWifiName(MainActivity.java:315)
可能是WIFI的名字过长溢出了
2.alpha_2.0 2016年1月6日16:56:12: (已经处理)
at android.view.ViewRootImpl.setView(ViewRootImpl.java:677)
at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:248)
at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)
at android.app.Dialog.show(Dialog.java:281)
at com.gc.materialdesign.widgets.SnackBar.show(SnackBar.java:93)
可能是因为activity被切换到后台导致的问题&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-1&quot;&gt;1. 使用说明&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;SDNU WIFI连接模块
1.首先在菜单选项里面找到&lt;code&gt;设置sdnu账号&lt;/code&gt;
2.进入设置账号
3.在首页即可使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：软件没有任务后台服务，只会在网络状态改变的时候被激活(重启手机后没有打开过或者被强制关闭过软件不会被激活)，并且连接后完全释放资源。由于sdnu网络环境比较复杂，并不能保证每一次都能自动连接到网络，没有接收到通知的时候可以手动启动软件连接。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;成绩查询模块
1.在菜单选项里面找到&lt;code&gt;本学期成绩&lt;/code&gt;和&lt;code&gt;计算绩点&lt;/code&gt;
2.进入输入教务处&lt;code&gt;学号&lt;/code&gt;和&lt;code&gt;密码&lt;/code&gt;即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：这是我见过最丑的界面= =&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;2. 关于&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.如果有意见请在下面留言或者发送邮件到 zhongjinbao1994@gmail.com，欢迎大家反馈
2.代码开源 不会窃取用户信息
3.唯一指定软件下载地址 &lt;a href=&quot;http://www.pgyer.com/upsdun&quot;&gt;upsdnu-蒲公英&lt;/a&gt;，不要相信其他途径，防止被钓鱼。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-3&quot;&gt;3. 软件部分截图&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot.jpg&quot; alt=&quot;截图2&quot; /&gt;
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot1_meitu_2.jpg&quot; alt=&quot;截图3&quot; /&gt;
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/screenshot2_meitu_3.jpg&quot; alt=&quot;截图1&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>为什么使用sudo命令执行sh会报command not found错误</title>
        <link>https://sendoh-akira.github.io/2015/11/22/linux-sduoshcommandnotfound.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/22/linux-sduoshcommandnotfound.html</guid>
        <pubDate>Sun, 22 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;明明sh文件存在,为什么还会说命令找不到呢?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/poechant/article/details/7216892&quot;&gt;参考博客-Linux下执行一些命令前加sudo时出现command not found的原因&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了科(翻)学(墙)上网,一直在用&lt;a href=&quot;www.laod.cn&quot;&gt;laod&lt;/a&gt;给的hosts,非常感谢!为了能高效的更换hosts,想用sh来完成.由于涉及了系统文件的操作,所以需要使用sudo来用root权限执行.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo changehosts.sh
sudo:changehosts.sh 找不到命令
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是输出PATH看了一下,路径设置是没问题的.只好请教万能的&lt;a href=&quot;www.google.com&quot;&gt;google&lt;/a&gt;,终于找到了答案.&lt;/p&gt;

&lt;p&gt;原来,在Linux下用sudo执行某一命令时,是在原进程(parent process)的基础上fork出来一个子进程(child process),这个子进程是以root权限执行的.然后在子进程中,执行你在sudo后面跟的命令.在子进程中是无法调用涉及到父进程的状态的一些命令的,所以非系统内置命令会被拒绝.这就是为什么会出现command not found的提示.
原因找到了,但是文中没有给解决办法.
那我们该怎么办呢?
我们可以用&lt;code&gt;su - root&lt;/code&gt;开启root账号,然后执行完在退出.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su - root
密码:
root@username:#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行完我们发现我们已经取得了root权限,这时候执行准没错了.
但是令人失望的是还是找不到命令,这又是怎么了?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $PTAH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出发现没有我们设置的shell路径了,恍然大悟,我们已经切换到了root账号下面,设置也已经变了.这样的话我们只要先进入预先的目录然后在执行,ok,成功.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>计算nextDay的实现</title>
        <link>https://sendoh-akira.github.io/2015/11/22/java-nextday.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/22/java-nextday.html</guid>
        <pubDate>Sun, 22 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;实现nextDay算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;1.题目要求&lt;/h2&gt;

&lt;p&gt;用户从键盘输入”2014/11/11”,然后输出该输入的下一天日期是多少.
要求很简单,看上去也不是很复杂,但是要考虑到闰年,月份进位等等问题.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.思路分析&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;用户输入合法性问题&lt;/li&gt;
  &lt;li&gt;nextDay的推算算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们先看第一个问题:
这个比较简单,我们可以使用正则表达式来匹配用户的输入,当然了,只是正则表达式可能还无法完全约束合法,我们可以继续针对个别的在正确的校验.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//使用分隔符'/'分割年月日
//年份可以使用09或者2009这样的形式 月份使用1或者01 日使用01或者1
//至少有一位 至多有两位
//则可以得到下面的匹配规则
String pattern = &quot;^(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\\/(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))$&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样,就可以得到一个合法的类似于”2013/14/22”这样的字符串,但是我们发现,14月仍然是不合法的,仍需我们再次校验合法性.于是,可以封装三个函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isLegalYear(int year) {
	return year &amp;gt;= 1900 &amp;amp;&amp;amp; year &amp;lt; 3000;
}

public static boolean isLegalMonth(int month) {
	return month &amp;lt;= 12 &amp;amp;&amp;amp; month &amp;gt; 0;
}

public static boolean isLegalDay(int month, int day) {
	return mapDay.get(month).intValue() &amp;gt;= day;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样,我们就可以得到一个正确合法的输入日期,然后就可以依照算法,计算下一天.&lt;/p&gt;

&lt;p&gt;再看第二个问题:
算法说起来也比较简单,类似于一个加法器,只是各个位置上的进位法则不一样而已.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将day自加1
    &lt;ul&gt;
      &lt;li&gt;若day合法,返回该data&lt;/li&gt;
      &lt;li&gt;若day不合法,day赋值为1,month自加1
        &lt;ul&gt;
          &lt;li&gt;若month合法,返回该data&lt;/li&gt;
          &lt;li&gt;若month不合法,month赋值为1,year自加,返回data&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过上述算法计算,即可得到正确的日期了.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.具体实现&lt;/h2&gt;

&lt;p&gt;首先封装一个data数据类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyData {
	public MyData(int year, int month, int day) {
		this.day = day;
		this.month = month;
		this.year = year;
	}
	public int year;
	public int month;
	public int day;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import java.util.*;
import java.util.regex.*;

public class NextDay{

	public static Map&amp;lt;Integer, Integer&amp;gt; mapDay = new HashMap&amp;lt;Integer, Integer&amp;gt;(){
		{
			put(1, 31); put(2, 28); put(3, 31); put(4, 30);
			put(5, 31); put(6, 30); put(7, 31); put(8, 31);
			put(9, 30); put(10, 31); put(11, 30); put(12, 31);
		}
	};

	public static void main(String[] args) {
		MyData d = getNextData(getData());
		System.out.println(d.year+&quot;-&quot;+d.month+&quot;-&quot;+d.day);
	}

	public static MyData getNextData(MyData data) {
		data.day++;
		if (isLegalDay(data.month, data.day)) {
			return data;	
		} else {
			data.day = 1;
			data.month++;
			if (isLegalMonth(data.month)) {
				return data;
			} else {
				data.month = 1;
				data.year++;
				return data;
			}
		}
	}

	public static MyData getData() {
		// get input from keyboard
		Scanner s = new Scanner(System.in);
		// month/day/year
		String input = s.next();
		// using Regular Expression to verify input
		String pattern = &quot;^(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\\/(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))$&quot;;
		Matcher m = Pattern.compile(pattern).matcher(input);
		if (m.matches()) {
			String[] data = input.split(&quot;/&quot;);
			int year = Integer.parseInt(data[0]);
			int month = Integer.parseInt(data[1]);
			int day = Integer.parseInt(data[2]);
			if (isLeapYear(year)) {
				mapDay.put(2, 29);
			}
			if (isLegalYear(year) &amp;amp;&amp;amp; isLegalMonth(month) &amp;amp;&amp;amp; isLegalDay(month, day)) {
				MyData d = new MyData(year, month, day);
				return d;
			} else {
				System.out.println(&quot;your input is illegal!&quot;);
				System.exit(-1);
				return null;
			}
		} else {
			System.out.println(&quot;your input format is worry!&quot;);
			System.exit(-1);
			return null;
		}
	} 

	public static boolean isLegalYear(int year) {
		return year &amp;gt;= 1900 &amp;amp;&amp;amp; year &amp;lt; 3000;
	}

	public static boolean isLegalMonth(int month) {
		return month &amp;lt;= 12 &amp;amp;&amp;amp; month &amp;gt; 0;
	}

	public static boolean isLegalDay(int month, int day) {
		return mapDay.get(month).intValue() &amp;gt;= day;
	}

	public static boolean isLeapYear(int year) {
		return (year % 400 == 0) || (year % 4 == 0 &amp;amp;&amp;amp; year % 100 != 0);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>数组中只出现一次的数字</title>
        <link>https://sendoh-akira.github.io/2015/11/19/algorithm-hash.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/19/algorithm-hash.html</guid>
        <pubDate>Thu, 19 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在牛客上看到了很多这种题目 今天总结一下吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?rp=2&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot;&gt;题目&lt;/a&gt;很简单:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;题目描述
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。&lt;/p&gt;

  &lt;p&gt;时间限制：1秒空间限制：32768K
通过比例：21.19%
最佳记录：0 ms|8552K&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一开始看到这个题目的时候,很简单的想到了在OJ上做过的一道题目-&lt;a href=&quot;http://www.acmicpc.sdnu.edu.cn/problem/show/1106&quot;&gt;1106.字符统计器&lt;/a&gt;.这个题目的思路就是把字符当做一个索引,然后在对应的数组里面进行计数操作.所以这里我也想到了同样的方法,把每一个数字稻作一个Key,把他的个数当做Value来进行操作.代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
import java.util.HashMap;
import java.util.Map;
public class Solution {
	public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
		if (array.length == 0 || array.length == 1) {
			num2[0] = num1[0] = 0;
		}
		HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; array.length; i++) {
			if (map.containsKey(Integer.valueOf(array[i]))) {
				map.put(Integer.valueOf(array[i]), new Integer(2));
			} else {
				map.put(Integer.valueOf(array[i]), new Integer(1));
			}
		}
		boolean isOne = true;
		for (Map.Entry&amp;lt;Integer, Integer&amp;gt; m : map.entrySet()) {
			if (m.getValue().intValue() == 1) {
				if (isOne) {
					num1[0] = m.getKey().intValue();
					isOne = false;
				} else {
					num2[0] = m.getKey().intValue();
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提交没问题,但是看了一看排行榜,发现C++大神都是0time就通过了= =
然后看了一下人家的代码,发现他们用的完全和我不是一个思路,用的异或运算!一开始我是觉得好神奇的然后就学习了一下.先总结一下大家的思路都有哪些吧.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;比较简单粗暴的,挨个数据检索,没除了他以外的所有元素比较.这个很容易想到,但是时间复杂度是n^2.&lt;/li&gt;
  &lt;li&gt;先排序,然后在检索,这个复杂度主要看排序算法,最好也是nlgn,最坏n^2.&lt;/li&gt;
  &lt;li&gt;和我上面的思路一样,用数做key,然后计数,复杂度为n.&lt;/li&gt;
  &lt;li&gt;重点说一下异或运算这个方法.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实这个思路也很简单:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先,有一个理论基础,就是相等的两个数异或运算后得0;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们对所有的数据都进行异或运算,最后会的到一个不为0的数,这个数是那两个不相同的数(n1,n2)的异或得到的.姑且先把这个数想象成一个二进制的数,他必然有一位是1(假设这个位置是onePosition),这个1的位置处n1,n2必然有一个是1一个是0;当然,这个1的值都是由很多数据参与计算得到的结果,但是影响都是抵消的,所以这里我们再次运用这个结论,我们把onePosition上为1的归为一组,为0的归为一组.这样n1,n2就分别进入了这两个组里,我们再一次进行异或,就可以得到这两个数了.
代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
import java.util.HashMap;
import java.util.Map;
public class Solution {
	public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
		if (array.length == 0 || array.length == 1) {
			num2[0] = num1[0] = 0;
		}
	
		int sum = 0;
		for (int i = 0; i &amp;lt; array.length; i++) {
			sum ^= array[i];
		}

		int onePosition = 0;
		for (int i = 0; i &amp;lt; 32; i++) {
			if (((sum &amp;gt;&amp;gt; i) &amp;amp; 1) == 1) {
				onePosition = i;
				break;
			}
		}

		for (int i = 0; i &amp;lt; array.length; i++) {
			if (((array[i] &amp;gt;&amp;gt; onePosition) &amp;amp; 1) == 1) {
				num1[0] ^= array[i];
			} else {
				num2[0] ^= array[i];
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>linux命令操作随记-不定时更新</title>
        <link>https://sendoh-akira.github.io/2015/11/15/linux-command.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/15/linux-command.html</guid>
        <pubDate>Sun, 15 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;使用linux的时候常常有些命令记不住 所以开一篇随时记录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;path&quot;&gt;1.如何添加path&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;2015年11月15日&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1.修改/etc/profile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/profile
//如果权限不够 请使用sudo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.修改path的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH = &quot;yourPathWantToBeSetted:$PATH&quot;
export PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.保存退出&lt;/p&gt;

&lt;p&gt;4.重启终端生效，或者使用source命令使其生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.验证&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $PATH //查看是否已经成功添加PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是我在按照上面的方法完成后还是只能一次终端生效，在开新的终端还是无效，于是我就尝试修改了一下&lt;code&gt;.bashrc&lt;/code&gt;,发现可以了。&lt;strong&gt;&lt;em&gt;注：我的系统是ubuntu-15.10&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//方法大体相同啦，稍微记录一下
//打开文件
vi .bashrc
//添加下面内容
export PATH=&quot;yourPathWantToBeSetted:$PATH&quot;
//esc : wq enter
//使其生效
source .bashrc
//验证
echo $PATH

//写一个shell放在目录下 就不会每次都add commit psuh了 一个命令同步博客 咩哈哈 爽~
/**
cd /home/jimbo/bornbeauty.github.io
git add -A
git commit -m &quot;addOrchange&quot;
git push
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是还有个小问题，就是commit里面有个参数，总是写那个敷衍的更新说明感觉很不爽，那就去看看shell参数好了～～～&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;符号&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当前脚本的文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$n&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$#&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的参数个数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的所有参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$@&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;上个命令的退出状态，或函数的返回值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;所以就很简单了，我们就用$n来获取参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /home/jimbo/bornbeauty.github.io
git add -A
git commit -m $1
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是问题又来了～有时候就是懒得不想写了怎么办！
好吧～判断一下是否为空吧～
&lt;a href=&quot;http://c.biancheng.net/cpp/view/7005.html&quot;&gt;shell选择语句语法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ condition ] //condition和[]必须间隔空格
	then
    	code
elif
	code
else
	code
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后的问题怎么判断为空呢？
&lt;a href=&quot;http://w55554.blog.51cto.com/947626/1223870&quot;&gt;shell怎么判断是否为空&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//最后代码变成了这个样子 试了试～ 挺好 开心
cd /home/jimbo/bornbeauty.github.io
git add -A
if [ $1 ]
	then
		git commit -m $1
else
	git commit -m &quot;changeOradd&quot;
fi

git push
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;section&quot;&gt;2.怎么移动复制文件&lt;/h6&gt;

&lt;p&gt;Linux下移动命令是mv（move的缩写），可以用来移动文件或者将文件改名。
命令格式：
mv [选项] 源文件或目录 目标文件或目录
命令参数：
-b ：若需覆盖文件，则覆盖前先行备份；
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖；
-u ：若目标文件已经存在，且 source 比较新，才会更新(update)。&lt;/p&gt;

&lt;p&gt;CP命令
格式: CP [选项]  源文件或目录   目的文件或目录
选项说明:-b 同名,备分原来的文件
-f 强制覆盖同名文件
-r  按递归方式保留原目录结构复制文件&lt;/p&gt;

&lt;h6 id=&quot;linux&quot;&gt;3.linux下的文件差异比较工具&lt;/h6&gt;

&lt;p&gt;diffuse&lt;/p&gt;

&lt;p&gt;安装方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install diffuse
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>简单的括号检查程序</title>
        <link>https://sendoh-akira.github.io/2015/11/09/java-comeputerTestHomework.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2015/11/09/java-comeputerTestHomework.html</guid>
        <pubDate>Mon, 09 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一个很简单的括号语法检查器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;&lt;em&gt;1.实现效果&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;首先我们先看一下我们实现的效果是什么样子的。
&lt;img src=&quot;http://7xjtan.com1.z0.glb.clouddn.com/testHomework-1.png&quot; alt=&quot;&quot; /&gt;
我们要实现的功能如下，&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;检查代码中括号的使用是否合法&lt;/li&gt;
  &lt;li&gt;指出括号使用出现了什么错误&lt;/li&gt;
  &lt;li&gt;指出哪个括号出现了问题，在行中找出他的位置&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;&lt;strong&gt;&lt;em&gt;2.核心算法&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;核心算法&lt;/strong&gt;并不是很复杂，如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历整个字符串序列
    &lt;ul&gt;
      &lt;li&gt;若遇到左括号，如“（”和“{”，则将其入栈&lt;/li&gt;
      &lt;li&gt;若遇到右括号，如“）”和“}”，则获取到栈顶元素s
        &lt;ul&gt;
          &lt;li&gt;如果当前元素c与s是匹配的，则说明这里括号使用没有语法错误&lt;/li&gt;
          &lt;li&gt;如果当前元素c与s不匹配，则说明这里的括号使用有语法错误，需要记录错误信息&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;否则就不处理，直接跳过该元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;遍历结束后检查栈
    &lt;ul&gt;
      &lt;li&gt;如果栈为空，则说明没有语法错误&lt;/li&gt;
      &lt;li&gt;如果栈不为空，则说明有语法错误，需要记录错误信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;&lt;strong&gt;&lt;em&gt;3.思路分析&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;我们首先按照算法理一下思路：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;我们要获取到文件里的字符信息，这里就要用到文件读写的内容；我打算包装一个&lt;strong&gt;ReadFile&lt;/strong&gt;类，让他完成这些工作。&lt;/li&gt;
  &lt;li&gt;对于这个程序我们关心的数据有括号、括号所在行号、括号所在行的内容以及括号在行里的位置；把这些数据封装成实体类&lt;strong&gt;SymbolEntity&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;这检查过程中我们还需要产生错误信息，这个错误信息也需要包装成类&lt;strong&gt;ErrorDescription&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;最后就是最核心的检查功能了，我们把他封装成&lt;strong&gt;CheckUtil&lt;/strong&gt;类；这个类实现检测功能和错误信息生成功能；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;&lt;strong&gt;&lt;em&gt;4.具体实现&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;SymbolEntity.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;public class SymbolEntity {
	private String symbol;
	private int lineNumber;
	private String lineContent;
	private int symbolNumber;

	public SymbolEntity(String symbol, int lineNumber, String lineContent, int symbolNumber) {
		this.symbol = symbol;
		this.lineNumber = lineNumber;
		this.lineContent = lineContent;
		this.symbolNumber = symbolNumber;
	}

	public String getSymbol() {
		return symbol;
	}

	public int getLineNumber() {
		return lineNumber;
	}

	public String getLineContent() {
		return lineContent;
	}

	public int getSymbolNumber() {
		return symbolNumber;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;ErrorDescription.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; public class ErrorDescription {
	private int errorLineNumber;
	private String errorDes;

	public ErrorDescription() {
	}

	public ErrorDescription(int errorLineNumber, String errorDes) {
		this.errorLineNumber = errorLineNumber;
		this.errorDes = errorDes;
	}

	public int getErrorLineNumber() {
		return errorLineNumber;
	}

	public String getErrorDes() {
		return errorDes;
	}

	public void setErrorLineNumber(int errorLineNumber) {
		this.errorLineNumber = errorLineNumber;
	}

	public void setErrorDes() {
		this.errorDes = errorDes;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;CheckUtil.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.util.Stack;
import java.util.*;
import java.io.IOException;
//要注意在代码或者注释中出现的'{','}','(',')'，也会影响我们的判断
// {    123
// }   125
// (    40
// )    41

//故意出一个错误
// {
public class CheckUtil {
	private List&amp;lt;ErrorDescription&amp;gt; mErrorList = new ArrayList&amp;lt;&amp;gt;();
	private String mFileName;
	private ReadFile mReadFile;
	private Stack&amp;lt;SymbolEntity&amp;gt; mStack = new Stack();
	private boolean isOverCheck = false;

	public CheckUtil(ReadFile mReadFile) {
		this.mReadFile = mReadFile;
		mFileName = mReadFile.getFileName();
	}

	public CheckUtil(String mFileName) throws NullPointerException, Exception {
		this.mFileName = mFileName;
		mReadFile = new ReadFile(mFileName);
	}

	public boolean startCheck() throws IOException {

		String lineContent = &quot;&quot;;
	
		while(null != (lineContent = mReadFile.next())) {
			for (int i = 0; i &amp;lt; lineContent.length(); i++) {
				switch(lineContent.charAt(i)) {
					case 123: 
						mStack.push(new SymbolEntity(String.valueOf((char)123), 
						mReadFile.getLineNumber(),
						lineContent,
						i+1));
						break;
					case 40:
						mStack.push(new SymbolEntity(String.valueOf((char)40), 
						mReadFile.getLineNumber(),
						lineContent,
						i+1));
						break;
					case 125:
						dealChar((char)125, (char)123, lineContent, i+1);
						break;
					case 41:
						dealChar((char)41, (char)40, lineContent, i+1);
						break;
				}
			}
		}

		while (!mStack.isEmpty()) {
			SymbolEntity entity = mStack.pop();
			switch(entity.getSymbol().charAt(0)) {
				case 123:
					buildError(entity, (char)125);
					break;
				case 40:
					buildError(entity, (char)41);
					break;
			}
		}

		isOverCheck = true;
	
		if (0 == mErrorList.size()) {
			return true;
		} else {
			return false;
		}
	}

	private void dealChar(char currentChar, char oppositeSymbol, String lineContent, int symbolNumber) {

		if (!mStack.isEmpty()) {
			SymbolEntity entity = mStack.peek();
			if (entity.getSymbol().charAt(0) != oppositeSymbol) {
				buildError(new SymbolEntity(String.valueOf(currentChar), 
				mReadFile.getLineNumber(), lineContent, symbolNumber), oppositeSymbol);		
			} else {
				mStack.pop();
			}	
		} else {
			buildError(new SymbolEntity(String.valueOf(currentChar), 
				mReadFile.getLineNumber(), lineContent, symbolNumber), oppositeSymbol);	
		}
	}

	private void buildError(SymbolEntity entity, char missSymbol) {
		//在什么什么文件里，第多少多少行的什么没有什么与之配对
		String result = &quot;在&quot; + mFileName + &quot;中,&quot; + &quot;第&quot; + (entity.getLineNumber()+1) +
			&quot;行的\&quot;&quot; + entity.getSymbol() + &quot;\&quot;没有\&quot;&quot; + missSymbol + &quot;\&quot;与之配对\n&quot;
			+ entity.getLineContent() + &quot;\n&quot;;

		for (int i = 1; i &amp;lt; entity.getSymbolNumber(); i++) {
			result += &quot; &quot;;
		}

		result += &quot;^&quot;;

		mErrorList.add(new ErrorDescription(
				entity.getLineNumber(),
				result)
		);
	}	

	public boolean isChecked() {
		return isOverCheck;
	}

	public List&amp;lt;ErrorDescription&amp;gt; getErrorList() {
		if (isOverCheck) {
			return mErrorList;
		} else {
			return null;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;ReadFile.java类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.io.*;

public class ReadFile {
	//{
	private String mFileName;			// file path
	private int mCurrentLine = 0;			// current line number
	private BufferedReader mBufferReader;	// read file class

	public ReadFile() {
	}

	public ReadFile(String mFileName) throws NullPointerException,Exception {
		if (null == mFileName) {
			throw new NullPointerException(&quot;file name is not allowed to be null&quot;);
		}

		if (!(new File(mFileName).isFile())) {
			throw new Exception(&quot;this filename is not a file&quot;);
		}

		this.mFileName = mFileName;

		mBufferReader = new BufferedReader(new 
		FileReader(mFileName));
	}

	public String next() throws IOException {
		mCurrentLine++;
		return mBufferReader.readLine();
	}

	public int getLineNumber() {
		return mCurrentLine;
	}

	public String getFileName() {
		return mFileName;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Main.java类 该类就是来测试其他类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.util.*;
import java.io.*;
import java.util.regex.*;

public class Main{
	public static void main(String[] args) {
	
		File file = file = new File(&quot;.&quot;);
		final String regex = &quot;.java&quot;;
		String[] list = file.list(new FilenameFilter() {
			@Override
			public boolean accept(File file, String name) {
				return name.contains(regex);
			}
		});

		Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);
		String s = &quot;&quot;;
		List&amp;lt;ErrorDescription&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;();
		for (String name : list) {
			try {	
				//System.out.println(name);
				ReadFile r = new ReadFile(name);
				CheckUtil c = new CheckUtil(r);
				if (c.startCheck()) {
					System.out.println(name +&quot;:没有错误&quot;);
				} else {
					lists.addAll(c.getErrorList());
				}
			} catch(Exception e) {
				System.out.println(&quot;出现未捕获的异常，信息如下：&quot;);
				e.printStackTrace();
				System.exit(-1);
			}
		}
		for (ErrorDescription e : lists) {
			System.out.println(e.getErrorDes());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Other</title>
        <link>https://sendoh-akira.github.io/2014/10/03/other.html</link>
        <guid isPermaLink="true">https://sendoh-akira.github.io/2014/10/03/other.html</guid>
        <pubDate>Fri, 03 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;技术点&lt;/p&gt;

&lt;p&gt;1.dubbo
2.zookeeper
3.kafka
4.RobbitMQ
Official Site  : https://www.rabbitmq.com/
what is RabbitMQ?
  a.Robust messaging for applications
  b.Easy to use
  c.Runs on all major operating systems
  d.Supports a huge number of developer platforms
  e.Open source and commercially supported
5.ActiveMQ
  Officaial Site: http://activemq.apache.org/
  what is ActiveMQ?
  Apache ActiveMQ ™ is the most popular and powerful open source messaging and Integration Patterns server.
  Apache ActiveMQ is fast, supports many Cross Language Clients and Protocols, 
  comes with easy to use Enterprise Integration Patterns and many advanced features while fully supporting JMS 1.1 and J2EE 1.4.
  Apache ActiveMQ is released under the Apache 2.0 License
Features
 Supports a variety of Cross Language Clients and Protocols from Java, C, C++, C#, Ruby, Perl, Python, PHP
 OpenWire for high performance clients in Java, C, C++, C#
 Stomp support so that clients can be written easily in C, Ruby, Perl, Python, PHP, ActionScript/Flash, Smalltalk to talk to ActiveMQ as well as any other popular Message Broker
 AMQP v1.0 support
 MQTT v3.1 support allowing for connections in an IoT environment.
 full support for the Enterprise Integration Patterns both in the JMS client and the Message Broker
 Supports many advanced features such as Message Groups, Virtual Destinations, Wildcards and Composite Destinations
 Fully supports JMS 1.1 and J2EE 1.4 with support for transient, persistent, transactional and XA messaging
 Spring Support so that ActiveMQ can be easily embedded into Spring applications and configured using Spring’s XML configuration mechanism
 Tested inside popular J2EE servers such as TomEE, Geronimo, JBoss, GlassFish and WebLogic
 Includes JCA 1.5 resource adaptors for inbound &amp;amp; outbound messaging so that ActiveMQ should auto-deploy in any J2EE 1.4 compliant server
 Supports pluggable transport protocols such as in-VM, TCP, SSL, NIO, UDP, multicast, JGroups and JXTA transports
 Supports very fast persistence using JDBC along with a high performance journal
 Designed for high performance clustering, client-server, peer based communication
 REST API to provide technology agnostic and language neutral web based API to messaging
 Ajax to support web streaming support to web browsers using pure DHTML, allowing web browsers to be part of the messaging fabric
 CXF and Axis Support so that ActiveMQ can be easily dropped into either of these web service stacks to provide reliable messaging
 Can be used as an in memory JMS provider, ideal for unit testing JMS
6.react&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>